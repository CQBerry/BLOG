<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/01/27/%E4%BB%80%E4%B9%88%E6%98%AFCookie/"/>
      <url>2021/01/27/%E4%BB%80%E4%B9%88%E6%98%AFCookie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宝藏翻译软件DeepL!</title>
      <link href="2021/01/26/%E5%AE%9D%E8%97%8F%E7%BF%BB%E8%AF%91%E8%BD%AF%E4%BB%B6DeepL/"/>
      <url>2021/01/26/%E5%AE%9D%E8%97%8F%E7%BF%BB%E8%AF%91%E8%BD%AF%E4%BB%B6DeepL/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.deepl.com/translator">DeepL</a>作为一款翻译软件，已经做出来很长时间了，相信很多小伙伴早已经听过这个翻译软件(Translator)的名号，网络上铺天盖地(<del>倒也不至于</del>)的文章，什么机器学习啊，爬虫啊，各种对它的介绍数不胜数，那么<del>我就来蹭一波热度</del>，来介绍一下这个DeepL Translator!</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/26/UxfumeO4Mqi9G13.png"></p><p>DeepL 翻译（DeepL Translator）是 2017 年 8 月由总部位于德国科隆的 DeepL GmbH（一家由 Linguee 支持的创业公司）推出的免费 神经机器翻译服务。评论家对于它的评价普遍正面，认为它的翻译比起 Google 翻译更为准确自然。(摘自维基百科)</p><p>DeepL的翻译服务搭建在Lineguee的数据库，并使用了卷积神经网络，开发者表示这是一种新型卷积神经网络，DeepL 的翻译是用一台浮点性能为 5 Petaflops 的超级电脑产生的，这台超级电脑位于冰岛，并依赖水力发电机来供电。一般来说卷积神经网络对于翻译长句子来说很有优势。</p><p>我们让DeepL Translator和Google Translator对比一下:</p><p>DeepL:</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/26/vikFyM1pm5PwcsX.png"></p><p>Google Translator:</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/26/paOARKXwjm4L1QB.png"></p><p>就可读性和口语化而言，我觉得DeepL的翻译更加本地化一点</p><hr><p>我们再来看一个例子：</p><p>这是我从网站上摘抄下来的一段话，我们看一下他的原翻译：</p><p>An individual human existence should be like a river—small at first, narrowly contained within its banks, and rushing passionately past boulders and over waterfalls. Gradually the river grows wider, the banks recede, the waters flow more quietly, and in the end, without any visible break, they become merged in the sea, and painlessly lose their individual being.</p><p>人的生命应当像河流，开始是涓涓细流，受两岸的限制而十分狭窄，尔后奔腾咆哮，翻过危岩，飞越瀑布，河面渐渐开阔，河岸也随之向两边隐去，最后水流平缓，森森无际，汇入大海之中，个人就这样毫无痛苦地消失了。</p><p>那这是DeepL的成绩：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/26/rDsXeLcMBiW5Ofz.png"></p><p>Google Translator:</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/26/lpDRcjbMrG9Nioz.png"></p><p>可以看到DeepL使用了很多<del>有深意</del>的词: 狭小，静谧</p><hr><p>上面我们看到的都是英文转中文，我们再尝试一下中文转英文，当然，普通的中文实在过于简单，我决定直接使用<strong>文言文</strong>来<del>虐</del>这<del>哥俩</del></p><hr><p>晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷。渔人甚异之，复前行，欲穷其林。</p><p>林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田、美池、桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。</p><p>见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。”</p><p>既出，得其船，便扶向路，处处志之。及郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。</p><p>南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终。后遂无问津者。</p><hr><p>这是魏晋时期陶渊明的词《桃花源记》，我用它作为测试样本（好像有点难为这<del>哥俩</del>了）</p><p>DeepL的成绩:</p><p>Jin Taiyuan, Wuling people fishing for business. When I was walking along the stream, I forgot the distance of the road. Suddenly, he came across a peach blossom forest, with hundreds of paces between the banks, no miscellaneous trees, fresh grass and colorful fallen Ying. The fisherman was very surprised, so he went ahead again and wanted to exhaust the forest.</p><p>When the forest was exhausted, he found a mountain with a small mouth, as if there was light. So he left his boat and entered through the mouth. At first it was very narrow, but only then did it allow people to pass. After a few dozen paces, it opened up. The land was flat and open, and the houses were in order, with good fields, beautiful ponds, mulberry and bamboo. Road traffic, dogs and chickens hear each other. Among them, men and women dressed as outsiders. The yellow-haired children, and happy to enjoy themselves.</p><p>When he saw the fisherman, he was surprised and asked where he had come from. He replied in kind. Then he wanted to return home and set up wine and killed a chicken for food. When the village heard of this man, they all came to ask about him. He told them that his ancestors had come to the village to escape the chaos of the Qin Dynasty, and that his wife had come to this desolate place. When he asked what time it was, he did not know there was a Han Dynasty, regardless of the Wei and Jin Dynasties. He told them what he had heard, and they all sighed. The rest of the group came back to his house and offered wine and food. They stopped for a few days and left. This person said, “It is not enough for outsiders to know.”</p><p>When he got out, he got his boat and helped him to the road. When he arrived at the county, he went to the governor and said so. The sheriff immediately sent someone to follow him, looking for what he wanted to do, but he was lost and never found the road again.</p><p>Liu Ziji of Nanyang, a noble scholar, heard about it and was glad to go. He was unsuccessful and died of illness. After that, there was no one who asked for help.</p><hr><p>Google Translator的成绩:</p><p>In the Taiyuan period of the Jin Dynasty, the people of Wuling made fishing. Travel by the river, forget the distance of the road. Suddenly there is a peach blossom forest, hundreds of steps across the bank, there are no miscellaneous trees, the grass is delicious, and the fallen flowers are colorful. The fisherman was very different, and went forward again, wanting to impoverish his forest.</p><p>If the forest is full of water, there will be a mountain with a small mouth, as if there is light. Convenience boat, enter from the mouth. Very narrow at the beginning, talented people. After dozens of steps, it suddenly became clear. The land is flat and the houses are just like farmland, beautiful pond, and mulberry bamboo. The traffic on the rice paddies, the chicken and the dog hear each other. Among them, the men and women are dressed like outsiders. The yellow hair hangs down, and he is happy.</p><p>Seeing the fisherman, I was shocked and asked everyone. Gu answered it. They had to return home and set up alcohol to kill chickens for food. The village heard that there was such a person, and came to inquire. Since Yun Xianshi escaped the chaos of the Qin Dynasty, and led his wife to come to this desperate situation, he never returned, so he was separated from outsiders. Asking what life is today, I don’t know whether there are Han, regardless of Wei Jin. This person was specific and heard one by one, and all sighed. The remaining people returned to their homes, all drinking and eating. Stop for a few days and resign. Someone said: “It’s not enough for outsiders.”</p><p>When you get out and get the boat, you will help you to the road and aim everywhere. And the county, the prefect, said so. The prefect sent people to follow him, looking for what he wanted, and then lost his way and no longer found the way.</p><p>Nanyang Liu Ziji, a noble scholar, heard about it, and walked happily. Unsuccessful, find the disease eventually. Then there were no interested parties.</p><p>我将它们的翻译结果重新翻译回中文，看看是否可读：</p><p>DeepL:</p><p>晋太原，武陵人钓商。沿溪而行，忘了路途的远近。忽见一桃花林，两岸相隔数百步，无杂树，草木鲜美，落英缤纷。渔夫大为惊奇，遂又前行，欲尽林中。</p><p>穷尽林中，忽见一山，口小，如有光。于是他离开船，从口中进入。初时十分狭窄，后来才让人通过。过了几十步，便豁然开朗。地势平坦开阔，房屋井然有序，良田美池，桑竹茂盛。道路交通，鸡犬相闻。其中，有男有女，装扮成外地人。黄发童子，乐此不疲。</p><p>渔夫见之，惊诧不已，问其从何而来。渔翁答以善意。遂欲归家，设酒杀鸡为食。村里人听说这个人，都来问他的情况。他告诉他们，他的祖先为了躲避秦朝的乱世，来到这个荒凉的地方，他的妻子也来到了这个村子。问他现在是什么时候，他不知道有汉朝，不管魏晋。他把所听到的情况告诉了他们，他们都叹了口气。其余的人又来到他家，献上酒菜。停了几日，便走了。此人说：”外人知道还不够。”</p><p>出门后，他取了船，扶他上路。到了县城，他到知县那里去说。县令立即派人跟踪他，寻找他要做的事，但他迷路了，再也找不到路了。</p><p>南阳的刘子骥是个贵族书生，听说了这件事，欣然前往。不料未能成功，病死。此后，无人问津。</p><p>Google Translator:</p><p>在金太原时期，武陵人捕鱼。在河边旅行，忘了路的距离。忽然有一片桃花林，横跨河岸几百步，没有杂树，草丛鲜美，落花缤纷。渔夫与众不同，他再次前进，想要使他的森林变得贫穷。</p><p>如果森林里到处都是水，那么山上就会有一小口，仿佛有光。方便船，从口进入。刚开始时人才很狭窄。经过几十个步骤，它突然变得清晰起来。土地平坦，房屋就像农田，美丽的池塘和桑bamboo。稻田上的交通，鸡和狗互相听见。其中，男女打扮得像局外人。黄头发垂下来，他很高兴。</p><p>看到渔夫，我很震惊，问了所有人。顾回答了。他们不得不返回家乡并建立酒精来杀死鸡肉作为食物。村里听说有这样一个人，就来询问。由于Yun贤石摆脱了秦朝的混乱，并带领他的妻子陷入了这种绝望的境地，他再也没有回来，因此与外界隔离。问今天的生活，我不知道是否有汉族，与魏晋无关。这个人很具体，一个人一个人听到，所有人都叹了口气。其余的人都回到家，喝酒和吃饭。停几天，然后辞职。有人说：“对于局外人来说这还不够。”</p><p>当您下船并乘船时，您将帮助您上路并瞄准任何地方。县长也这么说。县长派人跟随他，寻找他想要的东西，然后迷路了，不再找到路。</p><p>贵族学者南洋刘子集闻所未闻，开心地走着。不成功，最终找到疾病。那时没有感兴趣的团体。</p><blockquote><p>大致看去，想都不用想肯定是DeepL完胜，因为明明是英译中，Google Translator翻译的结果还存在英文字符，实属不应该</p></blockquote><p>我们再看一下翻译的结果，DeepL翻译的貌似还很有文言文那味儿，可读性很高；而Google Translator…<del>谷歌生草机(不是)</del></p><hr><p>总的来说，DeepL完全可以胜任日常的翻译工作，虽然免费版单词只能翻译5000个字符，不过瑕不掩玉，它配得上顶尖机器翻译的名号</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勾股定理的验证</title>
      <link href="2021/01/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86%E7%9A%84%E9%AA%8C%E8%AF%81/"/>
      <url>2021/01/25/%E5%8B%BE%E8%82%A1%E5%AE%9A%E7%90%86%E7%9A%84%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>今天我们来验证一下勾股定理(<del>因为实在是没有东西写了</del>)吧: </p><p>勾股定理(Pythagorean Theorem): </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/25/TpOUMjy7PaLVGgZ.png"></p><p>如上图所示，，在直角三角形ABC当中，</p><p>$$ a^2\ +\ b^2\ =\ c^2 $$</p><p>也就是说，出除了斜边之外的两条边的长度的平方<code>^2</code>相加 = 斜边长度的平方</p><hr><p>不管你是否记得勾股定理都不要紧，要紧的是，对这个定理进行验证之后，你感受到了什么，又学到了什么</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/25/lKjiSrQLxCNwZoT.png"></p><p>如上图所示，将四个直角三角形拼接在一起，形成一个边长为 $(a\ +\ b)$ 的大正方形，当中还有一个边长为 $c$ 的小正方形，让我们来看一下他们的面积：</p><p>大正方形的面积 = 小正方形的面积 + 直角三角形的面积 × 4 …❤</p><p>我们可以得出如上这样的一个答案</p><p>接下来，让我们用英文字符来表示面积：</p><ul><li><p>大正方形的面积为：$(a\ +\ b)^2$</p></li><li><p>小正方形的面积为：$c^2$</p></li><li><p>直角三角形的面积为：$a\ \times\ b\ \div\ 2\ =\ \frac{ab}{2}$</p></li></ul><p>我们将这些面积带入到❤号方程式当中去，得出：</p><p>$$(a\ +\ b)^2\ =\ c^2\ +\ \frac{ab}{2}\ \times\ 4\ =\ c^2\ +\ 2ab$$</p><p>然后我们再对等号左边的 $(a\ +\ b)^2$ 进行展开：</p><p>$$(a\ +\ b)^2\ =\ a^2\ +\ 2ab\ +\ b^2$$</p><blockquote><p>如果你没有掌握乘法公式的话，$(a\ +\ b)\ (a\ +\ b)\ =a^2\ +\ ab\ +\ ab\ +\ b^2$<br>那么你可以像这样实际计算一下，从而得到确认</p></blockquote><p>接下来将展开之后的 $(a\ +\ b)^2$ 带入到❤号方程式当中去：</p><p>$$a^2\ +\ 2ab\ +\ b^2\ =\ c^2\ +\ 2ab$$</p><p>最终得出：</p><p>$$ a^2\ +\ b^2\ =\ c^2 $$</p><p>至此，对勾股定理的验证就完成了，顺便还复习了一下乘法公式，一举两得，<del>岂不美哉(应该是水了一篇文章很爽)</del></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 勾股定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Hexo-Deploy的问题</title>
      <link href="2021/01/23/%E5%85%B3%E4%BA%8EHexo-Deploy%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/23/%E5%85%B3%E4%BA%8EHexo-Deploy%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在上次的<a href="https://www.chinq.xyz/2021/01/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84Deploy%E5%8A%9F%E8%83%BD/">《如何使用Hexo的Deploy功能》</a>这篇文章里，我详细介绍了hexo的deploy功能如何使用</p><p>但在那篇文章的评论区，我也说明了一个问题，就是每次deploy时，自定义域名都会变回原来的<code>username.github.io/repository</code>这样的格式，这样就很烦躁，每次deploy都要重新修改一次自定义域名，但是不用deploy就得手动<code>commit/push</code>，就很麻烦…</p><p>今天在无意间我和 <strong>sama(O7I2)</strong> 的一次通话中了解到了解决方法，分享给大家</p><hr><p>我以前在用Gridea写博客的时候，第一步肯定是配置，配置的时候会让我们选择输入<code>CNAME</code>，如果你配置了，每次部署时你会在Github仓库里看到<code>CNAME</code>这个文件，里面的内容就是你在<code>CNAME</code>那个输入框里写的</p><p>如果没有这个<code>CNAME</code>文件，Gridea每次部署也会变为<code>username.github.io/repository</code>，好了，现在知道问题出自哪了，每次部署(deploy)hexo的时候，hexo没有把<code>CNAME</code>文件连同你的博客文件一同部署上去，所以我们只需要让hexo每次部署时连同<code>CNAME</code>文件也部署上去就好了</p><p>可问题来了，如何让hexo部署<code>CNAME</code>文件呢，其实仔细观察一下，不难发现，我们的主题引用的<code>CSS, JS</code>等都会存放在<code>themes/theme_name/source/</code>下，而主题的完美运行也是需要这些文件的，所以hexo会在部署时会把这个/source文件夹的内容部署上去，所以我们只需要在这个文件夹下创建一个<code>CNAME</code>文件就好了</p><blockquote><p>注: <code>CNAME</code>文件不需要任何的后缀，内容为你的自定义域名，不要加 http/https!</p></blockquote><p>加入<code>CNAME</code>文件后使用<code>hexo clean</code>或<code>hexo cl</code>来清理你的/public文件夹，然后用<code>hexo g</code>重新生成，再使用<code>hexo deploy</code>或<code>hexo d</code>部署</p><p>部署好后尝试访问你的网站，就可以正常访问了，以后也不需要手动修改自定义域名了!</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Pjax实现网站无刷新加载？</title>
      <link href="2021/01/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Pjax%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E6%97%A0%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD/"/>
      <url>2021/01/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Pjax%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E6%97%A0%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="pjax是什么"><a href="#pjax是什么" class="headerlink" title="pjax是什么?"></a>pjax是什么?</h2><p>pjax 是一个 jQuery 插件，它通过 ajax 和 pushState 技术提供了极速的（无刷新 ajax 加载）浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。</p><p>pjax 的工作原理是通过 ajax 从服务器端获取 HTML，在页面中用获取到的 HTML 替换指定容器元素中的内容。然后使用 pushState 技术更新浏览器地址栏中的当前地址。</p><p>以下两点原因决定了 pjax 会有更快的浏览体验：</p><ol><li><p>不存在页面资源（JS/CSS）的重复加载和应用；</p></li><li><p>如果服务器端配置了 pjax，它可以只渲染页面局部内容，从而避免服务器渲染完整布局的额外开销</p></li></ol><h3 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h3><p>jQuery-pjax 的维护方向：可能会继续修复重要的 bug，但其功能不会再发生变化，即不会再实现新功能，也不会再扩展现有功能</p><h2 id="如何使用pjax"><a href="#如何使用pjax" class="headerlink" title="如何使用pjax?"></a>如何使用pjax?</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端设置分两步：</p><ol><li><p>下载插件，包括 jQuery1.8+，或者 npm 安装，这部分参考文档，不赘述</p></li><li><p>初始化 pjax 插件，并有条件的拦截</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.fn.pjax</span><br></pre></td></tr></table></figure><p>以下代码表示：当 selector 被点击时，执行 ajax 请求，并将返回的 HTML 字符串填充在 container 标记的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).pjax(selector, [container], options)</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>selector：string 类型，用于 click 事件委托 的选择器</li><li>container：string 类型，用于标识唯一 pjax 容器的选择器</li><li>options object 类型，包含下列选项</li></ul><p>pjax 配置选项</p><table><thead><tr><th>选项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>timeout</td><td>650</td><td>ajax 超时时间（毫秒），超时后强制刷新整个页面</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>push</td><td>true</td><td>使用pushState在浏览器中添加历史记录</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>replace</td><td>false</td><td>替换 URL 地址但不添加浏览器历史记录</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>maxCacheLength</td><td>20</td><td>容器元素缓存内容的最大值（次）</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>version</td><td></td><td>string 或 function，返回当前 pjax 版本</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>scrollTo</td><td></td><td>浏览器滚动条的垂直滚动位置。设为 false 时禁止滚动</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>type</td><td>“GET”</td><td>参考<code>$.ajax</code></td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>dataType</td><td>“HTML”</td><td>参考<code>$.ajax</code></td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>container</td><td></td><td>被替换内容元素的 CSS 选择器</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>url</td><td>link.href</td><td>string 或 function，返回 ajax 请求响应的 URL</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>target</td><td>link</td><td>pjax事件中 relatedTarget 属性的最终值</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>fragment</td><td></td><td>CSS 选择器，提取 ajax 响应内容中指定的内容片段</td></tr></tbody></table><p>可以在全局使用 <code>$.pjax.defaults</code> 对象改变默认配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.pjax.defaults.timeout = <span class="number">1200</span></span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端也比较简单，监听 HTTP 的 header 中有 X-pjax 的 ajax 请求，如果有则返回 HTML 片段，而不是整个 HTML</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><h3 id="fn-pjax"><a href="#fn-pjax" class="headerlink" title="$.fn.pjax"></a>$.fn.pjax</h3><p>最简单常见的 pjax 使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).pjax(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;#pjax-container&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过这种方式可以让页面中所有的链接都实现 pjax 加载，并指定 #pjax-container 作为容器元素</p><hr><h3 id="pjax-click"><a href="#pjax-click" class="headerlink" title="$.pjax.click"></a>$.pjax.click</h3><p>这是一个 <code>$.fn.pjax</code> 内部使用的底层方法，通过此方法可以在 pjax 事件之上做更多的事情。本示例使用当前的 click 上下文来设置一个祖先元素作为容器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($.support.pjax) &#123;</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;a[data-pjax]&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> container = $(<span class="built_in">this</span>).closest(<span class="string">&#x27;[data-pjax-container]&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> containerSelector = <span class="string">&#x27;#&#x27;</span> + container.id</span><br><span class="line">        $.pjax.click(event, &#123;<span class="attr">container</span>: containerSelector&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pjax-submit"><a href="#pjax-submit" class="headerlink" title="$.pjax.submit"></a>$.pjax.submit</h3><p>通过 pjax 提交表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;submit&#x27;</span>, <span class="string">&#x27;form[data-pjax]&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    $.pjax.submit(event, <span class="string">&#x27;#pjax-container&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="pjax-reload"><a href="#pjax-reload" class="headerlink" title="$.pjax.reload"></a>$.pjax.reload</h3><p>使用 pjax 机制发起一个当前 URL 的请求到服务器，并且通过响应的内容替换容器元素中的内容，同时不添加浏览器历史记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.pjax.reload(<span class="string">&#x27;#pjax-container&#x27;</span>, options)</span><br></pre></td></tr></table></figure><h3 id="pjax"><a href="#pjax" class="headerlink" title="$.pjax"></a>$.pjax</h3><p>手动调用 pjax。主要用于非 click 事件发起 pjax 请求的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyFilters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = urlForFilters()</span><br><span class="line">    $.pjax(&#123;<span class="attr">url</span>: url, <span class="attr">container</span>: <span class="string">&#x27;#pjax-container&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>除了 pjax:click 和 pjax:clicked，其他所有 pjax 事件都是在 pjax 容器元素上触发的。</p><table><thead><tr><th>事件</th><th>取消</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>pjax 链接事件的生命周期</td><td></td><td></td><td></td></tr><tr><td>—</td><td></td><td></td><td></td></tr><tr><td>pjax:click</td><td>✔︎</td><td>options</td><td>链接被激活的时候触发；取消的时候阻止 pjax</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:beforeSend</td><td>✔︎</td><td>xhr, options</td><td>可以设置 XHR 头</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:start</td><td></td><td>xhr, options</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:send</td><td></td><td>xhr, options</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:clicked</td><td></td><td>options</td><td>pjax 通过链接点击已经开始之后触发</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:beforeReplace</td><td></td><td>contents, options</td><td>从服务器端加载的 HTML 内容完成之后，替换当前内容之前</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:success</td><td></td><td>data, status, xhr, options</td><td>从服务器端加载的 HTML 内容替换当前内容之后</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:timeout</td><td>✔︎</td><td>xhr, options</td><td>在 options.timeout 之后触发；除非被取消，否则会强制刷新页面</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:error</td><td>✔︎</td><td>xhr, textStatus, error, options</td><td>ajax 请求出错；除非被取消，否则会强制刷新页面</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:complete</td><td></td><td>xhr, options</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>浏览器前进后退事件的生命周期</td><td></td><td></td><td></td></tr><tr><td>—</td><td></td><td></td><td></td></tr><tr><td>pjax:popstate</td><td></td><td>direction事件的属性: “back”/“forward”</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:start</td><td>null, options</td><td>内容替换之前</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:beforeReplace</td><td>contents, options</td><td>在用缓存中的内容替换 HTML 之前</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:end</td><td>null, options</td><td>替换内容之后</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:callback</td><td>null, options</td><td>页面脚本加载完成后（Admui 项目）</td><td></td></tr></tbody></table><p>如果您使用了加载指示（如 loading 图标或 “加载中” 的文字），pjax:send 和 pjax:complete 这两个事件会比较有用。它们只有在 XHR 请求（而不是从缓存中加载内容）时才会被触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;pjax:send&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#loading&#x27;</span>).show()</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;pjax:complete&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#loading&#x27;</span>).hide()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以下是禁用 pjax:timeout 事件的示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;pjax:timeout&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent default timeout redirection behavior</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在地址栏输入URL后，浏览器发生了什么？</title>
      <link href="2021/01/20/%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>2021/01/20/%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者<a href="https://www.jianshu.com/u/e8e57b673e6b">Dreammin_chen</a>，转载自<a href="https://www.jianshu.com/p/c1dfc6caa520">简书</a>，转载时有改动</p></blockquote><p><strong>在浏览器中输入URL后，浏览器都发生了哪些事情呢？</strong>跟我一起来看看吧：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/20/hcaCu1tyHUZgF6v.png"></p><p>我将该过程分为了以下六步：</p><h3 id="1-DNS-域名解析"><a href="#1-DNS-域名解析" class="headerlink" title="1. DNS 域名解析"></a>1. DNS 域名解析</h3><ul><li>在浏览器 DNS 缓存中搜索</li><li>在操作系统 DNS 缓存中搜索</li><li>读取系统 hosts 文件，查找其中是否有对应的 IP</li><li>向本地配置的首选 DNS 服务器发起域名解析请求</li></ul><h3 id="2-建立-TCP-连接"><a href="#2-建立-TCP-连接" class="headerlink" title="2. 建立 TCP 连接"></a>2. 建立 TCP 连接</h3><p>为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK (acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。<br> TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题</p><h3 id="3-发起-HTTP-请求"><a href="#3-发起-HTTP-请求" class="headerlink" title="3. 发起 HTTP 请求"></a>3. 发起 HTTP 请求</h3><p>请求方法：</p><ul><li> GET: 获取资源</li><li> POST: 传输实体主体</li><li> HEAD: 获取报文首部</li><li> PUT: 传输文件</li><li> DELETE: 删除文件</li><li> OPTIONS: 询问支持的方法</li><li> TRACE: 追踪路径</li></ul><p>请求报文：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/20/cq2hpOrHkXYjNJS.png"></p><h3 id="4-接受响应结果"><a href="#4-接受响应结果" class="headerlink" title="4. 接受响应结果"></a>4. 接受响应结果</h3><p>状态码：</p><ul><li> 1**： 信息性状态码</li><li>2**： 成功状态码<br> 200：OK 请求正常处理<br> 204：No Content 请求处理成功，但没有资源可返回<br> 206：Partial Content 对资源的某一部分的请求</li><li>3**： 重定向状态码<br> 301：Moved Permanently 永久重定向<br> 302：Found 临时性重定向<br> 304：Not Modified 缓存中读取</li><li>4**： 客户端错误状态码<br> 400：Bad Request 请求报文中存在语法错误<br> 401：Unauthorized 需要有通过 Http 认证的认证信息<br> 403：Forbidden 访问被拒绝<br> 404：Not Found 无法找到请求资源</li><li>5**： 服务器错误状态码<br> 500：Internal Server Error 服务器端在执行时发生错误<br> 503：Service Unavailable 服务器处于超负载或者正在进行停机维护</li></ul><p>响应报文：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/20/fIj95mlRTNPHCAG.png"></p><h3 id="5-浏览器解析-HTML"><a href="#5-浏览器解析-HTML" class="headerlink" title="5. 浏览器解析 HTML"></a>5. 浏览器解析 HTML</h3><p>浏览器按顺序解析 HTML 文件，构建 DOM 树，在解析到外部的 CSS 和 JS 文件时，向服务器发起请求下载资源，若是下载 CSS 文件，则解析器会在下载的同时继续解析后面的 HTML 来构建 DOM 树，则在下载 JS 文件和执行它时，解析器会停止对 HTML 的解析。这便出现了 JS 阻塞问题</p><p><strong>预加载器</strong>：<br>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 HTML，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。<br> 注：预解析并不改变 DOM 树，它将这个工作留给主解析过程</p><p>浏览器解析 CSS，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素）</p><blockquote><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p></blockquote><h3 id="6-浏览器布局渲染"><a href="#6-浏览器布局渲染" class="headerlink" title="6. 浏览器布局渲染"></a>6. 浏览器布局渲染</h3><ul><li>布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li><li>绘制：将计算好的每个像素点信息绘制在屏幕上</li></ul><p>在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/20/xeAwPEHzM8pF4tc.png"></p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个Terraria的奇妙好东西</title>
      <link href="2021/01/19/%E8%AE%B0%E4%B8%80%E4%B8%AATerraria%E7%9A%84%E5%A5%87%E5%A6%99%E5%A5%BD%E4%B8%9C%E8%A5%BF/"/>
      <url>2021/01/19/%E8%AE%B0%E4%B8%80%E4%B8%AATerraria%E7%9A%84%E5%A5%87%E5%A6%99%E5%A5%BD%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>HI!</p><p>这里是CHINQ啊，Terraria有个奇妙的东西</p><p>就是在旅途模式下的官方作弊的东西（鬼知道Terraria官方为什么要开发这个），反正特别强就是了</p><p>可是旅途模式只能在旅途地图使用，那么有没有什么办法把在旅途模式的作弊插件放到普通地图（除旅途外的所有类型地图）使用呢？</p><p>官方肯定是不允许你这样做的，但是，有一种东西，它叫：</p><p><strong>人物存档修改器</strong>…</p><hr><p>在旅途模式里，有很多作弊用的东西，就拿这个<code>God Mode</code>举例子，这玩意就相当于锁血，锁蓝（就是不掉血，不消耗魔法啦），那么这个东西要怎么带到别的地图使用呢？接着往下看吧！</p><p><a href="https://yal.cc/r/terrasavr/"><strong>Terrasavr</strong></a>————YellowAfterLife大佬开发的一个人物存档修改器，有网页端和客户端（<strong>不是广告</strong>）</p><blockquote><p>注: 因为是外国服务器，可能需要梯子，梯子请自备</p></blockquote><p>网站上有部分汉化的简体中文，字体也使用了Terraria的风格（只有英文才是），主界面是这样的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/RyCJeAWa82HSYIw.png" alt="image.png"></p><p>选择加载存档：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/d73BAFfYT9XK52z.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/v28W5cr3gpV1Bwi.png" alt="image.png"></p><blockquote><p>不要在意我这个人物存档，乱改的，这里我只说说怎么把旅途模式的<code>God Mode</code>（其他同理）允许在其他存档使用</p></blockquote><hr><p>首先先在Terraria创建一个旅途人物，随便进入一个地图，把<code>God Mode</code>打开，保存并退出，接着你就可以找到你的人物存档是一个叫做：</p><p><code>name.plr</code>的文件（不知道存档在哪里的见上面的图）</p><p>我们将这个文件载入到Terrasavr中，并将其模式修改为除旅途模式的任意一个其他模式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/Bjn2mzG6Mrp8hEs.png" alt="image.png"></p><p>然后保存存档，将该存档覆盖你的老存档，现在即可进入其他世界体验旅途的快乐（不是）了！</p><p>因为旅途模式的<code>God Mode</code>并不依赖旅途使用，所以只修改模式并不会影响它的使用</p><p>总结：<br>创建旅途存档，把想要的作弊模式打开，<br>导入存档至Terrasavr，把模式修改为旅途之外，<br>保存存档，覆盖之前的老存档，<br>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> 水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terraria </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是RSA?</title>
      <link href="2021/01/18/%E4%BB%80%E4%B9%88%E6%98%AFRSA/"/>
      <url>2021/01/18/%E4%BB%80%E4%B9%88%E6%98%AFRSA/</url>
      
        <content type="html"><![CDATA[<div class="note success flat"><p>强烈建议放大观看，Mathjax渲染的公式有点小，见谅！</p></div><p>一直到上个世纪70年代，人们都还在使用对称加密算法，也就是说信息的收发方会通过事先商定好的密钥对数据进行加密和解密 </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/17/QlDfwCdoiGFamLr.png" alt="image.png"></p><p>然而，这种加密方式有诸多缺陷，随着网络规模的不断增大，每多一个用户就需要保存额外的密钥，密钥的管理也将逐渐成为所有人的负担 </p><p>更加致命的是，密钥必须通过见面协商，而没有办法通过网络进行交换，因为密钥的传输过程需要进行加密，而没有密钥，则不能进行加密 </p><p>那有没有一种可能性，我们用不同的密钥对数据进行加密和解密</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/17/AzEm1Xr4OT5ayLe.png" alt="image.png"></p><p>对数据加密的密钥，即公钥，是公开的，而对数据解密的密钥却仅为接收者持有？</p><p><strong>这个问题，在1978年得到了解答</strong></p><hr><p>因为公钥是对所有人公开的信息，我们需要保证数据被公钥加密后，不能轻易地反推出来，那么什么算法单项计算容易，反推却极难呢？</p><p><strong>模运算</strong>(Modular Artithmetic)，又称求余计算，像计算机中的假随机生成的随机数，散列算法都是他的典型应用 </p><p>我来举个例子：</p><p>$$3^3\ mod\ 7$$</p><p>很简单，答案是6</p><p>$$3^3\ mod\ 7\ =\ 6$$</p><p>但已知答案是<code>6</code>，要求<code>x</code>，就很难了</p><p>$$3^x\ mod\ 7\ =\ 6$$</p><p>因为模运算不可逆的原因，我们只能带进一个数值一个一个去试，那如果这里出现了超级大的数，想逆推这个等式几乎不可能</p><p>$$3^x\ mod\ 9871649871751784351784561874657819346\ =\ 6$$</p><p>而公钥加密正是利用了模运算的这个特性，假设我们将原始数据表示成一个数<code>m</code>(message)，我们对它求<code>e</code>次幂</p><p>$$m^e$$</p><p><strong>e(encrypt)可以看成我们加密使用的密钥</strong></p><p>然后我们将结果除以N并取余数，最后得到密文<code>c</code>(cipher)</p><p>加密:</p><p>$$m^e\ mod\ N\ =\ c$$</p><p>解密:</p><p>$$c^d\ mod\ N\ =\ m$$</p><p><strong>d(decrypt)可以看成我们解密使用的密钥</strong></p><p>综合一下这两个式子，合并成下面这样:</p><p>$$m^{ed}\ mod\ N\ =\ m$$</p><p>可以发现，如何选取这里的<code>e, d</code>变成了公钥加密中最关键的问题…</p><hr><p>1763年，欧拉有了一个重要发现 ———— 欧拉定理(Euler’s Theorem)</p><p>$$m^{\phi(n)}\ =\ 1\ (mod\ n)$$</p><p>对于一个任何与<code>n</code>互质的正整数<code>m</code>，提取他的<code>φ(n)</code>次方，并处以<code>n</code>去余数，结果永远等于<code>1</code></p><p>那么，<code>φ(n)</code>又是什么呢？</p><p>它代表在小于或等于<code>n</code>的正整数中，有多少个与<code>n</code><strong>互质</strong>的数</p><p>我举个例子，这里我们取<code>n = 6</code></p><p>我们会发现在小于等于<code>6</code>的正整数中，只有<code>1</code>和<code>5</code>与<code>6</code>互质，所以<code>φ(6) = 2</code></p><p>了解了<code>φ</code>后，我们回到欧拉定理，尝试着对公式进行一些简单的变换</p><p>$$m^{\phi(n)}\ =\ 1\ (mod\ n)$$</p><p>在等式的两端取<code>k</code>次幂</p><p>$$m^{k\phi(n)}\ =\ 1\ (mod\ n)$$</p><p><strong><code>k</code>在这里代表任意的正整数</strong></p><p>接着我们在两端同时乘<code>m</code></p><p>$$m^{k\phi(n)+1}\ =\ m\ (mod\ n)$$</p><p>最后我们将模运算写在等式的左边</p><p>$$m^{k\phi(n)+1}\ mod\ n\ =\ m$$</p><p>将这个公式和上面的加密解密公式对应起来，我们会发现这里公式的指数部分相同，则我们可以将<code>d</code>与<code>e</code>的关系表示成这种形式:</p><p>$$d\ =\ \frac{k\phi(n)+1}{e}$$</p><p>我们可以通过选取这里的<code>k, n, e</code>来计算出解密的密钥<code>d</code></p><p>而这个公式中的<code>φ(n)</code>，不是那么的简单，但它还恰巧是公钥加密中最关键的部分</p><p>实际上，要计算出<code>φ(n)</code>的唯一办法就是对这个<code>n</code>做质因数分解，然而大数的质因数分解本身是非常困难的事情，所以说当<code>n</code>特别大时，对<code>φ(n)</code>的求解可以看作是计算上不可行的</p><p>但是，如果<code>n</code>本身就是一个质数，那么情况就会有所改变</p><p>比如质数<code>7</code>，小于等于<code>7</code>的并于<code>7</code>互质的数有<code>1-6</code>，所以<code>φ(7)=6</code></p><p>所以，只要<code>n</code>是质数，则<code>φ(n) = n - 1</code></p><p>φ函数还有一个重要的特性，就是:</p><p>$$\phi(p\ \times\ q)\ =\ \phi(p)\ \times\ \phi(q)$$</p><p>例如，我们可以选取两个质数，<code>17</code>和<code>23</code>，则:</p><p>$$\phi(17\ \times\ 23)\ =\ \phi(17)\ \times\ \phi(23)\ =\ 16\ \times\ 22\ =\ 352$$</p><p>因此我们可以轻易求得$\phi(17 \times 23) = \phi(391) = 352$</p><p>带入我们之前的公式:$d\ =\ \frac{k\phi(n)+1}{e}$</p><p>然后选取一个较小的数<code>e = 3</code>，这里我们需要保证它与<code>φ(n)</code>互质</p><p>于是在<code>k = 5</code>的情况下：</p><p>$$d\ =\ \frac{k\phi(n)+1}{e}\ =\ \frac{5\ \times\ 352\ +\ 1}{3}\ =\ 587$$</p><p>求出了私钥<code>d</code>，我们不需要<code>p</code>和<code>q</code>了，算法会将<code>e</code>和<code>n</code>公布，做加密的公钥<code>(public key)</code>，而<code>d</code>做保存下来作为解密时用的私钥<code>(private key)</code></p><p>其他人因为不知道<code>p, q</code>这两个关键的质因数，也没有办法计算出<code>φ(n)</code>，也没法破解这里的私钥<code>d</code></p><p>公钥加密正是利用了这个信息不对等，让加密者能够快速构造出一个<code>φ(n)</code>，而其他人却无法在有限的时间内求解它</p><p>我们可以用求得的<code>e, d, n</code>来模拟一段信息加密解密过程：</p><p>$$e\ =\ 3\ |\ d\ =\ 587\ |\ n\ =\ 391$$</p><p>我们要加密的字符是<code>a</code>，<code>a</code>的ascii编码是<code>97</code>，所以<code>m = 97</code></p><p>于是$97^3\ mod\ 391\ =\ 79$，<code>79</code>是我们加密后的密文，即<code>c</code></p><p>为了解密，我们计算$79^{587}\ mod\ 391\ =\ 97$，计算出原始数据为<code>97</code></p><p>以上讲到的，便是公钥加密算法的全部工作原理，这个算法在首次被发现后就被政府作为机密尘封起来，后来又在1977年又被三个麻省理工的数学家独立发掘，即为当下众所周知的著名的RSA算法，RSA这个名字也是由三位数学家的姓来命名的：</p><p>Ron <strong>R</strong>ivest | Adi <strong>S</strong>hamir | Leonard <strong>A</strong>dleman</p><p>RSA在各个领域都被有所应用，像数字签名，数字证书，SSH、HTTPS的加密连接，全部都是RSA的典型应用。在实际使用中，由于公钥加密的计算量大，速度慢，通常他会和加密对称算法一起使用：</p><p>公钥加密算法常被用作最初连接的建立，而真正数据传输的过程会交给对称加密算法来处理</p><p>以上便是公钥加密算法RSA的全部奥秘，总结一下：</p><p>双方都生成私钥和公钥，<br>双方只首次建立链接时互相交换公钥，<br>然后双方互相用对面的公钥进行数据加密，<br>双方互相发送加密后的密文，<br>然后双方自己用自己本地的私钥进行解密</p><p>也就是说整个过程中：网络中交换数据时用对面给的公钥加密；本地自己收到加密后的密文后自己用私钥解密</p><p>因为整个过程只有公钥加密后的密文，还有公钥在网络上传递，而该密文因为即时你知道公钥，也由于大数难以质数分解的原因无法反推，必须用私钥解密，所以是很安全的</p><p>用人话说就是：见面时，我给你一把打开的锁，但是不给你钥匙，你给我发送文件就用我的锁给锁上，然后我自己能用钥匙打开但是别人因为没钥匙打不开，而因为我一直拿着钥匙没给别人看过，所以也不可能有人偷了我的钥匙</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Hexo的Deploy功能</title>
      <link href="2021/01/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84Deploy%E5%8A%9F%E8%83%BD/"/>
      <url>2021/01/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84Deploy%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>最近我在部署我的Hexo博客时遇到了这个问题，就是每次生成博客文件时都要手动push就很麻烦，这篇教程就教大家如何正确打开hexo的deploy功能</p><h2 id="注册Github账号并配置SSH-KEY"><a href="#注册Github账号并配置SSH-KEY" class="headerlink" title="注册Github账号并配置SSH-KEY"></a>注册Github账号并配置SSH-KEY</h2><p>相信注册Github账号这个大家都会，就不说了，详细说一下这个配置ssh-key</p><ol><li>首先配置Git的登陆信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的github用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的github登录邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>生成 SSH 公私钥<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的github登录邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>设置 Github 的 ssh key<br>将 id_rsa.pub 的内容拷贝到 Github 的 ssh key 中<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/16/YxaU6wNIFlbMcfX.png" alt="image.png"></li><li>测试链接 Github 设置的 ssh key 免登陆是否生效<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ol><hr><p>上面的步骤配置好了后，下面的配置就很简单了</p><ol><li>新建git仓库<br>不说</li><li>配置 _config.yml<br>这个在你的hexo根目录的_config.yml中有写，这里放张截图<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/16/MnFpYBlk8XQocsb.png" alt="image.png"><br><strong>branch不写的话它默认新建一条gh-pages分支，请注意</strong></li><li>安装hexo deploy插件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>安装好后就可以直接deploy到github了</li><li>Deploy到Github<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嗨! 是我啊!</title>
      <link href="2021/01/16/%E5%97%A8!%20%E6%98%AF%E6%88%91%E5%95%8A!/"/>
      <url>2021/01/16/%E5%97%A8!%20%E6%98%AF%E6%88%91%E5%95%8A!/</url>
      
        <content type="html"><![CDATA[<h2 id="对你没看错CQ又把他的blog大改了一顿"><a href="#对你没看错CQ又把他的blog大改了一顿" class="headerlink" title="对你没看错CQ又把他的blog大改了一顿"></a>对你没看错CQ又把他的blog大改了一顿</h2><p>这次真的超级<strong>香</strong>!<br>因为我终于搞懂butterfly这个主题咋用了!<br>Hexo香!!<br>(<del>太激动了</del>)<br>这回应该是 真 · 可能不改了<br>(<del>不是</del>)<br>完活(<del>耶，又水了一篇</del>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 又双叒叕 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
