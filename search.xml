<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>来迟了的 介绍 Windows 11</title>
      <link href="posts/e0d04ffa.html"/>
      <url>posts/e0d04ffa.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近因为很忙导致没有更新什么东西, 挤出点时间搬运一篇吧(搬运 Windows 11 介绍文章什么的才不是蹭热度呢<br>本文作者 Clyde、化学心情下2、广陵止息, 转载自<a href="https://sspai.com/post/67413">少数派</a>, 转载时有改动</p></blockquote><p>6 月 24 日晚, 微软通过线上发布会正式公布了自家的下一代桌面操作系统更新, 此前预热已久但不幸泄露的 Windows 11 也终于来到了大家面前</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/0d68284ad5d0541f96c8237b8b066c57"></p><p>如果不考虑泄露版, 这次 Windows 11 作为 6 年来的首次大更新还是带来了不少可圈可点的更新看点, 无论是外观设计到交互体验再到软件、游戏体验都有不少值得期待的地方</p><p>本文根据微软发布会上公布的相关视频及图片资料整理了大部分 Windows 11 的更新内容, 希望能为你提供一些参考</p><p><strong>注：发布会视频及图片的展示内容与最终的实际体验可能会有差异</strong></p><h2 id="加入圆角与色彩潮流-还有新的开始菜单"><a href="#加入圆角与色彩潮流-还有新的开始菜单" class="headerlink" title="加入圆角与色彩潮流, 还有新的开始菜单"></a>加入圆角与色彩潮流, 还有新的开始菜单</h2><p>相比 Windows 10, Windows 11 最直观的变化自然在外观设计</p><p>和泄露版展示的体验一样, Windows 11 将任务栏图标进行了居中处理。默认的任务栏图标包括开始菜单、搜索、桌面切换以及小组件（Widgets）, 开始菜单图标采用了与 Windows 11 相符的新设计, 位置则依然在最左侧</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/7946ac6ab2f8621e38bcfaf003fa54bd.png"></p><p>新版开始菜单正式弃用了「动态磁贴（Live Tiles）」这一标志性设计, 没了大色块、直角和框线, 布局更加清爽；结合宣传视频展示的内容和泄露版的现有体验, 开始菜单除了允许用户固定常用 App 到面板中上部分, 还会在面板下方提供应用和最近使用过的文档建议；老用户熟悉的所有应用列表入口则在面板右上方</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/6bb21bf43b496ca2620779059def6551"></p><p>从任务栏和开始菜单也不难看出, 微软也将在 Windows 11 中启用一套全新的默认图标, 这与微软今年对 Windows 图标的翻新工作可以说是一脉相承的。而除了这些我们在泄露版中已经体验过的内容, 本次发布会公布的宣传视频中也给出了大量设计翻新细节, 比如新版系统设置、新的主题系统、暗色模式等等</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/7fecdd4c192aaf23e10d138f2de21cfb"></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/2a8d47417f5510e4d97c6806a2abff73"></p><p>值得一提的是, 在发布会后上传的 <a href="https://www.youtube.com/watch?v=g7y1S3wIysg">Watch how Windows 11 is being designed</a> 视频中, 微软还提到了 Windows 11 的整体设计理念变迁, 包括对字体的重新设计（主要指不久前更新的 <a href="https://blogs.windows.com/windows-insider/2021/05/06/announcing-windows-10-insider-preview-build-21376/">Segeo UI 可变英文字体</a>）, 圆角、层次和阴影的运用, 壁纸的动态, 材质的模拟……以及色彩提取, 没错, 说到主题系统, 最有意思的是和 Android 12 的 Material You 类似, Windows 11 也有一套能够从壁纸中取色并应用在系统 UI 中的主题系统, 那个在视频中一闪而过的新版资源管理器就用到了这种取色方案</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/58648f8cc682a55232dc741eccd9425f.jpg"></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/341507f2d708f7013c9ea53354a51e26"></p><p>至于圆角, Windows 开发团队认为圆角的引入更加适合触屏交互形态, 配合适当的色彩, 也更能给人一种温润、柔软的可触碰感。除了 Windows 11 操作系统, 我们在 Edge、Office 等微软自家应用中应该也能看到越来越多的圆角设计</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/6e095fefcfcc8076a6847e2fcd0d34a3"></p><h2 id="PowerToys-部分失业-多任务处理更方便"><a href="#PowerToys-部分失业-多任务处理更方便" class="headerlink" title="PowerToys 部分失业, 多任务处理更方便"></a>PowerToys 部分失业, 多任务处理更方便</h2><p>交互体验的改进是本次 Windows 11 的更新重点</p><p>贴靠布局（Snap Layouts）迎来了新的呈现形式, 相比于 Windows 10 的需要依赖鼠标在显示器边缘触发, Windows 11 将方式重新整合进了最大化窗口按钮中。当我们把鼠标悬浮在最大化窗口按钮上时就可以看到各种贴靠方式, 方便随时调用和排布</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/5d0c0e4405c80c985b70a12259effe56"></p><p>Windows 11 的贴靠分组（Snap Groups）也会记住我们使用了哪些应用程序, 还会将它们的贴靠布局记录下来。最典型的场景就是当前的工作被即时通讯消息打断了, 依靠贴靠分组功能我们只需要再点击一次就能回到之前的应用和布局, 继续推进工作</p><p>这个功能看起来很像是 Windows 10 中跳票多年的 Sets, 也像是我们此前多此推荐过的 PowerToys 迎来了一次「转正」</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/b7db2e9818a8e2b9efc8cf2724d10687"></p><p>更值得称道的是, Windows 11 中贴靠分组功能不仅会记住当前显示器的贴靠布局, 还会记住所有外接显示器的贴靠布局。当我们重新将笔记本接到外接显示器上时, 贴靠分组会自动还原之前的贴靠布局——在正确的显示器上打开对应的窗口, 方便我们重新开展工作。微软还表示贴靠分组功能可以配合虚拟桌面使用, 方便用户并行处理多个场景的任务</p><p>最后, Windows 11 还针对平板电脑以及其他触摸设备做了不少额外改进：断开物理键盘后, 所有任务栏图标间距会自动增加, 以适应更大的触摸范围并提供一定的视觉提示；Windows 11 还将把触摸板手势带到触摸屏上, 带给用户更统一的触摸体验</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/79d7f6a8bfaf6f6169d307ac243d1174.png"></p><h2 id="全新应用商店-内置-Android-应用"><a href="#全新应用商店-内置-Android-应用" class="headerlink" title="全新应用商店, 内置 Android 应用"></a>全新应用商店, 内置 Android 应用</h2><p>比起外观和交互上的变化, Windows 11 的软件体验改进则可谓重磅</p><p>微软对 Windows 11 内置的 Microsoft Store 软件商店进行了架构上的重构, 未来应用商店里除了包含 Windows 10 上已有的 UWP 应用外、也将支持上架 win32 应用甚至是 Android 应用。这当中有两个值得关注的点：</p><p>首先是应用商店政策。微软表示新版应用商店允许开发者自选结算系统, 通过这种方式从商店中获取的收益将全数归开发者所有, 微软不会进行任何抽成（后续微软也向 The Verge 证实 这一策略不适用于游戏）；如果开发者采用微软提供的结算系统, 所得收入的抽成比例则会是 15%（应用）和 12%（游戏）, 比起 App Store 和 Google Play 依然可谓「实惠」</p><p><strong>另一方面, Windows 11 将原生支持运行 Android 应用</strong></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/f7560cefc0da1475a097220068312fcd"></p><p>完全重塑一个自己的 Android 应用商店并不现实, 所以在新版软件商店中, Android 应用的分发将依靠亚马逊应用商店, 微软软件商店则负责内容展示；不过 Android 应用运行起来并不需要 Android 系统环境, 可以和当前的 Windows 桌面环境完美适配, 比如可以将应用固定在任务栏上</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/article/544ac7fa88ecfd7bd56deb477c837932"></p><p>唯一的限制是 Windows 11 中的 Android 应用显然没有 Google Play 框架可以依赖, Google 系的应用以及一些需要 Google Play 服务的应用在 Windows 11 上可能无法正常工作</p><p>借助开源的 Android 生态, 微软似乎想「补全」其生态中一直缺失的重要一环 —— 也就是移动端。其实从 Apple 开始让 macOS 运行 iPadOS 应用就不难看出, 未来桌面系统和移动系统的差别会越来越小, 并且最终很有可能趋同、融合成同一个操作系统</p><p>除了应用商店, Windows 11 也将 Skype 淡出舞台并默认内置了 Microsoft Teams 作为沟通应用。和搜索、多任务处理类似, Teams 在 Windows 10 中甚至拥有一个独立的任务栏图标位置, 点击任务栏图标即可快速开启 Teams 聊天面板；微软似乎想为 Windows 11 打造一个「Facetime」, 而 Teams 这款既可以用在家庭、也可以用在商务办公领域的效率协作工具, 就再适合不过了</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/8f8c85194e8029362d176e003dababf6.jpg"></p><p>最后, 此前已经向 Windows 10 用户全量推送的「资讯和兴趣」面板在 Windows 11 中也进一步进化为独立的小部件（Widgets）功能, 也就是新版任务栏中开始菜单右侧的第三个图标。从微软给出的演示来看, 小部件面板除了展示用户关心的资讯卡片, 还支持用户固定一些自己常用的 app 小部件, 如微软待办、OneDrive、Edge 必应搜索等等</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/e6892ae86ee47858d33a6248fb908ef5.jpg"></p><h2 id="Xbox-技术下放-画质更好、加载更快"><a href="#Xbox-技术下放-画质更好、加载更快" class="headerlink" title="Xbox 技术下放, 画质更好、加载更快"></a>Xbox 技术下放, 画质更好、加载更快</h2><p>除了效率与沟通, 游戏也是 Windows 11 的主打体验之一。在这里, 坐拥 Xbox 游戏主机的微软可以说是来了一次全面的技术下放</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/ee913235124bf8c85cb4d152c258ea70.png"></p><p>比如此前为 Xbox Series X|S 独占的 Auto HDR 技术, 在 Windows 11 中, 只要游戏基于 DirectX 11 及以上版本开发, 就能自动应用来自 Auto HDR 的画质升级, 带来更宽广的动态范围和色彩质感</p><p>与之类似的, Xbox Series X|S 上那套全新的读写系统 —— DirectStorage 技术也将下放至 Windows 11。DirectStorage 能够减少游玩过程中后台材质串流所需要的读写性能需求, 进而允许系统将 CPU 算力合理分配到图形、NPC 加载等其他任务上去, 减少游戏加载时间并提升游戏体验</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/62570248643cf05b65e695602f8f7449.png"></p><p>目前微软官方已在 Windows 11 <a href="https://www.microsoft.com/zh-cn/windows/windows-11-specifications">规格</a> 界面展示了 DirectStorage 和 Auto HDR 的具体硬件需求：DirectStorage 功能需要 NVMe SSD、使用「标准 NVM Express 控制器」驱动程序和支持 Shader Model 6.0 的 GPU；Auto HDR 则仅需一台支持 HDR 的显示器</p><p>此外微软还提到了一个名为「专为 DirectStorage 优化（DirectStorage Optimized）」的 Windows 11 PC 认证, 这些设备估计可以开箱即用, 直接享受到 DirectStorage 带来的游戏体验提升</p><p>最后, Windows 11 也将搭载全新的 Xbox 客户端, 允许用户通过 Xbox Game Pass 享受到来自微软的庞大游戏阵容；订阅了 Xbox Game Pass Ultimate 的用户还能通过 Xbox app 进行 Xbox 云游戏串流</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://cdn.sspai.com/2021/06/25/fb98206a301100b09cc407651ec40a83.jpg"></p><p>参考链接：<a href="https://news.xbox.com/en-us/2021/06/24/windows-11-the-best-windows-ever-for-gaming/">Windows 11: The Best Windows Ever for Gaming - Xbox Wire</a></p><h2 id="点评-amp-升级指南"><a href="#点评-amp-升级指南" class="headerlink" title="点评 &amp; 升级指南"></a>点评 &amp; 升级指南</h2><p>Windows 11 的确是一次大更新, 但整合版 Teams 在国内的网络表现, 新版商店在国内应用商店审查策略下的最终体验, 背靠 MSN 中文网低质量资讯来源的 Widgets……将这些部分刨除之后, 它对大部分国内 Windows 用户来说就更像是一次界面与交互的更新了</p><p>而国内 Windows 用户对界面与交互的变化向来不怎么买账</p><p>如果你想尝鲜, 下周一（6 月 28 日）开始就可以通过 Windows Insider 开发者预览计划的 Dev 通道体验到 Windows 11 测试版了, 我们也将在第一时间上手进行体验；正式版预计将于 2022 年初推出, 符合条件的 Windows 10 用户均可免费升级, 你可以 使用本工具 检查你的电脑是否符合升级的要求</p><p>附 · Windows 11 仅提供 64 位处理器支持, 不会提供 32 位版本, 硬件则需要符合以下标准：</p><ul><li>处理器：1GHz 或更快, 在兼容的 64 位处理器或 SoC 上有 2 个或更多核心</li><li>内存：4GB</li><li>存储器：64GB 或更大的存储设备</li><li>系统固件：UEFI, 支持 Secure Boot</li><li>TPM：可信平台模块（TPM）2.0 版</li><li>图形卡：兼容 DirectX 12 或更高版本的 WDDM 2.0 驱动</li><li>显示器：对角线大于 9 英寸的高清晰度（720p）显示器, 每条颜色通道 8 比特</li></ul>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬运 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Android S(12) 中的一些较大的改变</title>
      <link href="posts/1712c7b9.html"/>
      <url>posts/1712c7b9.html</url>
      
        <content type="html"><![CDATA[<p><strong>Google I/O 21’</strong> 在最近线上举行, 有很多内容在这次大会中提到, 最重要的, 肯定还是最近关于 <strong>Android S</strong> 的一些<strong>开发细节</strong>。</p><p>我看完了整场 I/O 大会, 总结出了 <strong>Android 12</strong> 的 <strong>3</strong> 大改变: <strong>样式</strong> / <strong>隐私</strong> / <strong>系统底层</strong></p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>倘若把 <strong>UI</strong> 看作一个产品的话, 美观度、设计感也是一个重中之重的要素</p><p>到底多重要呢？</p><p>当我看完 <strong>Google I/O 2021</strong> 大会后, 在脑子里回荡的并不是 <strong>Google</strong> 的 <strong>AI 赋能</strong>有多强, <strong>AI 学习</strong>有多厉害, 也没有感叹到 <strong>Google</strong> 会携手三星欲重振 <strong>Wear OS</strong>, 欲与 <strong>Apple Watch</strong> 分庭抗礼。印象最深的是 <strong>Google</strong> 为 <strong>Android 12</strong> 所设计的<strong>新设计语言 Material You</strong></p><p>大概是这么重要吧, 虽只惊鸿一瞥, 但足以深入脑海</p><p>玩到了极致的个性化</p><p>往年的每个 <strong>Android</strong> 大版本都会在 <strong>UI</strong> 上做出<strong>一点细节</strong>的改动, 以迎合<strong>当下交互</strong>或者 <strong>App 设计</strong>上的<strong>潮流</strong>。而早在 <strong>2014</strong> 年诞生的 <strong>Material Design</strong> 在 <strong>Google</strong> 不断的<strong>推动改进</strong>下, 一直用到了 <strong>Android 11</strong></p><p><strong>Material Design</strong> 的设计语言从早期的<strong>卡片式设计</strong>、<strong>纸张的模拟</strong>、<strong>强烈对比色</strong>, 渐渐演变成现在的<strong>多变的形状</strong>、<strong>配色</strong>以及<strong>针对全面屏的优化适应</strong>等等</p><p>到了 <strong>Android 12</strong> 上的 <strong>Material You</strong>, 实则它也是由 <strong>Material Design</strong> 演化而来, 也算是几年来 <strong>UI</strong> 细节改动的<strong>量到质</strong>的改动, 从名字上就可以看出, <strong>Android 12</strong> 的 <strong>UI</strong> 开始回归「个性化」。</p><p>相对于封闭的 <strong>iOS, Android</strong> 自诞生起, 强调的是开源, 打的就是个性化这张牌。经历与 <strong>Android 10</strong> 非常相似 <strong>Android 11</strong> 升级之后, <strong>Google</strong> 终于在外观上<strong>大刀阔斧</strong>。</p><p>从 <strong>Google I/O</strong> 大会上给到的信息来看, <strong>Android 12</strong> 外观上的「个性化」是以壁纸为中心, 「动态调色板」能够从壁纸中提取相关的颜色, 并添加上互补色从而生成动态主题, 由此来说, 每部 <strong>Pixel</strong> 都会有着<strong>极为个性</strong>的主题呈现方式</p><p>桌面上的小部件也有了改变, <strong>Android 12</strong> <strong>强制小部件圆角</strong>, 这使得用户看到的都是圆角, 不会存在太大的<strong>割裂感</strong>。形状依旧维持 <strong>Android 11</strong> 形态, 但 <strong>Android 12 Beta 1</strong> 重构了小部件的菜单, <strong>组织的层级关系更好</strong>, 选择更<strong>方便</strong></p><p>在动效上, <strong>Android 12</strong> 的<strong>非线性过渡</strong>用的更多, 更<strong>贴近自然和直觉</strong>。系统级的滚动特效升级到了「过渡滚动」效果, 包括垂直和水平滚动双向, 取代以前 <strong>Android</strong> 版本中的发光效果</p><p><strong>下拉菜单</strong></p><p>下拉菜单的快速设置区域内的按钮变得更大, 整体呈圆角矩形, 所能呈现更多的信息, 一目了然, 按钮更大也可以方便的定位和触控。只是默认情况下只有四个选项可以查看, 相对于 <strong>Android 11</strong> 来说是减少了, 这个设计算是一个取舍</p><p><strong>新锁屏时钟</strong></p><p>默认没有通知的情况下, <strong>Android 12 Beta 1</strong> 的锁屏时钟设计在屏幕中央, 采用了<strong>更大</strong>的字体, 更为醒目。<del>(超爱!!)</del></p><p><strong>新的信息聚合通知</strong></p><p>在有一系列通知后, 屏幕的主角就变成「通知」, 而时钟就被「挤」到屏幕的左上角。当把这些通知消除之后, 时钟会「膨胀」至屏幕中央, 成为主角</p><p><strong>新的「过渡滚动」动效</strong></p><p>在设置菜单中, 当你滑动到边界时, 整个菜单列表会「非线性伸展」, 表示到达边界, 相对于以前的发光特效, 要来的更为直觉。不过现在「过渡滚动」特效还只是系统级的, 并没有扩展到 <strong>App</strong> 内, 比如 <strong>Chrome</strong> </p><h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>在 <strong>Android 12</strong> 中, 谷歌引入了 <strong>Android</strong> <strong>私有计算核心</strong>, <strong>增强保护用户个人信息的安全性</strong>、<strong>私密性</strong>。私有计算核心实现了<strong>实时字幕</strong>、<strong>智能回复</strong>等功能。所有的音频和语言处理都发生在设备上, <strong>与网络隔离</strong>, 以<strong>保护你的隐私</strong>。与 <strong>Android</strong> 系统的其他部分一样, 私有计算核心的保护措施是<strong>开源</strong>的, 完全可以由安全社区检查和验证</p><p>有意思的是, 通过 <strong>Android 12</strong>, 用户可以控制自己的汽车。谷歌表示, 当前正在与汽车制造商合作在 <strong>Android 12</strong> 中开发一个新的数字汽车钥匙, 通过这个功能, 用户能够从自己的手机上锁定、解锁, 甚至启动汽车</p><p><strong>Android 12</strong> 延续此前 <strong>Android</strong> 版本在系统隐私上的所做的努力, 新的<strong>隐私仪表板（Privacy Dashboard）</strong>会以时间线的形式展示应用们<strong>调用位置、麦克风、摄像头、剪切板等敏感动作</strong><del>(绝对不是什么见者有份之类的)</del></p><h2 id="系统底层"><a href="#系统底层" class="headerlink" title="系统底层"></a>系统底层</h2><p>除了个性化、隐私, <strong>Android 12</strong> 也优化了底层性能占用, 让整个系统变得<strong>更轻快、灵敏</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>Beta 1</strong> 并非完全兑现了 <strong>Android 12</strong> 所有的新功能, 外观上「<strong>动态调色板</strong>」并未现身。而隐私上的麦克风、相机调用提示, 和快速设置切换界面也未能上线。长按电源激活 <strong>Google Assistant</strong> 功能也没有出现, 依旧是关机、重启等选项（此功能会在 Beta 2 版本上线）</p><p>关于隐私, Beta 1 延续的是 Android 11 的设置页面, 新的隐私仪表板（Privacy Dashboard）也要等到 Beta 2 版本才会出现在系统之中</p><p>最后放出 <strong>Android 12</strong> 官方宣传片</p><iframe src="https://player.bilibili.com/player.html?bvid=BV1yh411v7Sj"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Termux 的妙用</title>
      <link href="posts/f084d9a6.html"/>
      <url>posts/f084d9a6.html</url>
      
        <content type="html"><![CDATA[<p>Termux 想必大家都不陌生, 是一款在 Android 上出色的终端工具, 可以做一些计算量不高的小工作, 但是它其实还有别的用处, 就比如下面这个: </p><hr><h2 id="搭建文件服务器"><a href="#搭建文件服务器" class="headerlink" title="搭建文件服务器"></a>搭建文件服务器</h2><p>一想到要把文件从手机电脑上互传就头疼, 文件传输助手等工具的步骤又过于繁琐, 怎么办?</p><p>可能你会想到用数据线把手机电脑连接起来, 或者通过某某网盘进行传输</p><p>其实完全没有必要, 家里都有无线局域网吧, 我们可以通过局域网传输(该方法仅限单向)</p><ul><li><p>首先, 你需要在手机上下载好 <a href="https://termux.com/">Termux</a></p></li><li><p>接着, 替换 pkg(apt) 的源, 这里以清华(Tuna)源为例子</p></li></ul><hr><p>下载 nano 文本编辑器: <code>pkg install nano</code></p><p>更换默认文本编辑器为 nano: <code>export EDITOR=nano</code></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/05/02/iGWTplF8g5MDKtY.jpg"><br>换源, 把<code>http://mirrors.tuna.tsinghua.edu.cn/termux</code>覆盖掉原来的: <code>apt edit-sources</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 连接远程仓库, 获取软件包信息</span><br><span class="line">pkg update</span><br><span class="line"></span><br><span class="line"># 更新本地已经安装的软件包</span><br><span class="line">pkg upgrade</span><br></pre></td></tr></table></figure><p>换好后使用命令更新一遍</p><hr><p>现在我们就可以正式开始了, 首先赋予 Termux 读取存储空间的权限, 使用命令: <code>termux-setup-storage</code></p><p>会弹出一个对话框, 我们点击允许(始终允许)</p><p>这样会在当前目录下生成一个叫 <code>storage</code> 的子目录, 该目录就会是我们文件服务器的根目录</p><h3 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h3><p>这里以 Python 搭建 http-server 为例, 首先安装 Python: <code>pkg install python</code></p><p>回到 <code>~/storage</code> 目录: <code>cd ~/storage</code></p><p>使用命令开启 http-server: <code>python -m http.server [port]</code></p><blockquote><p>[port] 为端口号, 可以省略, 默认为 8000</p></blockquote><p>开好后会显示如下信息: </p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/05/02/vK26bzX3joYVp4I.jpg"></p><p>这就代表开启成功了, 现在去手机设置里找到手机的 <code>IPv4</code> 地址, 开头一般为 <code>192.168</code>, 我的是 <code>192.168.18.9</code></p><p>那么我们在浏览器地址栏输入 192.168.18.9:[port] 即可访问(前提是手机和电脑处在同一个局域网内)</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/05/02/M7IvtT4pEuYxfyZ.png"></p><p>获取文件的同时会在终端上显示日志, 方便查看(图上展示的为连接成功的日志, 并非传输文件的日志)</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/05/02/g3tMwyrcL7p2BO1.jpg"></p><blockquote><p>你可能会疑惑, 明明自己手机根目录的文件比文件服务器上显示出来的多的多, 为什么文件服务器上只有几个文件夹, 那是因为手机的根目录在 <code>shared/</code> 这个目录下, 进去会显示隐藏文件, 你会看到一堆平常没有看过的文件夹</p></blockquote><blockquote><p>尾注: 该篇文章的手机截图里的 Termux 我使用了 oh-my-zsh, 有需要我可以出一篇如何在 Termux 上安装 oh-my-zsh 的教程</p></blockquote><p>(End)</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 原理解析</title>
      <link href="posts/341c55b.html"/>
      <url>posts/341c55b.html</url>
      
        <content type="html"><![CDATA[<p>这个世界出现了 HTTPS , 是出于隐私和安全考虑的, 假如这个世界没有 HTTPS , 而只有使用明文传输的 HTTP 会怎么样:</p><h2 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h2><hr><p>我们首先想象出一个 客户端(C)和服务端(S)</p><p>然后 C 向 S 明文传输了一个数据, 叫做 data(未加密)</p><p>这个 data 是以明文的方式存在于网络之中, 假如这时一个黑客(hacker)杀了进来</p><p>这个 hacker 很容易就可以获取到这个 data, 那假如这个 data 是你的账户密码, hacker 可以很轻松的把你的钱全部转走</p><p>显然这种方式是不可取的, 尤其是在电子货币高度发达的今天</p><hr><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><hr><p>防止 hacker 再次把你的密码获取, 你有一个算法(f_1), 并且有一个密钥(k)</p><p>那么你现在传输数据, 首先会计算加密后的数据</p><blockquote><p>加密后的数据 = f_1(k, data) = x_1</p></blockquote><p>那么这个 f_1 还有一个兄弟算法叫做 f_2</p><blockquote><p>原 data = f_2(k, x_1) = data</p></blockquote><p>了解了对称加密的基本原理后, 我们在回到刚才的传输过程</p><p>C 向 S 索要 k</p><p>C 把加密好的 x_1 发送给 S , S 可以使用 k 解密</p><p>假如这时又有一个 hacker 杀了进来, 截获到了 x_1 , 但是 hacker 不知道 k 也就无法得知 data</p><p>但真的是这样吗?</p><p>S 在制定 k 的时候不可能知道一共有多少个客户端, 也不可能为每一个客户端都量身订制一个 k , 也就是说这个 k 只能有一个</p><p>问题来了, S 不知道 hacker 是黑客, 照样会老老实实的把 k 告诉 hacker , 那么 hacker 有了 k , 自然可以把 x_1 解密出 data</p><p>如果每个人都用相同的 k 做密钥, 那么加密毫无意义</p><hr><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><hr><p>你现在有一个算法(f)和公钥(pk), 服务端(S)拥有私钥(sk)和公钥(pk)且只有服务端知道私钥</p><blockquote><p>公钥加密data: f(pk,data) = x<br>私钥解密x: f(sk,x) = data<br>私钥加密data: f(sk,data) = x’<br>公钥解密x’: f(pk,x’) = data</p></blockquote><p>首先 C 向 S 索取 pk</p><p>C 加密 data ( <code>f(pk,data)</code> ) 得到 x , 并发送给 S </p><p>S 通过 sk 解密 x 得到 data ( <code>f(sk,x) = data</code> )</p><p>这个过程看似很完美, hacker 截取到 x , 但因为没有 sk 所以无法解密</p><p>但是这个过程有一个致命的缺点, 就是 S 如何向 C 发送数据</p><p>S 向 C 发送数据肯定不能使用 pk 加密, 要不然就和对称加密一样了, 那么只能使用 sk 加密出 x’</p><p>S 向 C 发送 x’</p><p>C 使用 pk 解密出 data</p><p>这里犯了和对称加密一样的错误, 因为 hacker 也可以拿到 pk , 因为 pk 人人可以拿到, 所以非对称加密也是不可行的</p><hr><p>有一群聪明的数学家从对称加密和非对称加密中获取了灵感, 分析了它们的缺点</p><p>对称加密的缺点是 k 只能有一个, 否则就是完美无缺的</p><p>非对称加密的缺点是 S 向 C 传输数据的过程</p><p>这群数学家想出了一个近乎完美的解决办法, 就那就是将二者结合起来</p><hr><h2 id="对称-非对称"><a href="#对称-非对称" class="headerlink" title="对称 + 非对称"></a>对称 + 非对称</h2><hr><p>首先, S 拥有 pk &amp; sk</p><p>C 向 S 索取 pk</p><p>C 生成一个字符串(num1)</p><p>C 使用 pk 加密 num1 发送给 S, 假设它叫 y</p><p>然后 S 对 y 使用 sk 解密出 num1</p><p>这个 num1 就作为之后加密用的 k</p><p>S 通知 C 协商完毕, 之后的加密都使用 num1(k)</p><p>传输数据过程就变为和对称加密一样, 只不过 k 变成了临时协商的 num1</p><p>因为 num1 是临时协商的, 所以 hacker 截获到了 密文(x) 也无法解密</p><p>但这并不是无懈可击的, 我们的 hacker 脑洞大开, 想出了一种新的解决办法</p><hr><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><hr><p>在 C 向 S 索取 pk 之前, hacker比他们还快一步，充当了一个假的 S 向 C 提供 pk’</p><blockquote><p>因为不是 S 的 pk 我们把 hacker 的 pk 叫做 pk’</p></blockquote><p>C 以为获取到了 pk 很开心, 很快就生成了 num1</p><p>hacker 装扮成好人, 去找 S 索取 pk</p><p>然后 C 把 num1 使用 pk’ 加密为 yy(和y区分), 发送给 hacker</p><p>hacker 拿到 yy 后使用自己的 sk’ 解密出 num1 后, 依旧演戏, 通知 C 协商完毕, 后面的加密使用 num1</p><p>然后 hacker 做了第二手打算, 充当自己是无辜的良民, 使用刚才获取到的 pk 把 num1 加密发送给 S</p><p>S 不知道是 hacker 的请求, 还傻乎乎的通知 hacker 协商成功</p><p>之后 C 向 hacker 发送加密数据 x, hacker 也向 S 发送 x</p><p>S 向 hacker 返回 x’, hacker 向 C 返回 x’</p><p>且因为 hacker 获取到了 num1, 过程中所有数据 hacker 都可以解密</p><p>假如你向小明转账 1000元, hacker 就可以把收款人改成自己, 并且向你返回错误的信息让你误以为转账成功</p><p>那么有没有什么办法可以避免中间人问题呢</p><p>我们分析一下, C 在向 S 获取 pk 的第一步, hacker 就已经截胡, 这就导致 C 认为 hacker 就是 S</p><hr><h2 id="对称-非对称-CA"><a href="#对称-非对称-CA" class="headerlink" title="对称 + 非对称 +  CA"></a>对称 + 非对称 +  CA</h2><hr><p>解决中间人问题其实也很简单，我们引入一个权威的 CA 机构</p><p>因为 C 向 hacker 请求 pk 不知道这个 pk 其实是 pk’, 所以我们可以让 CA 把这个 pk 认证一下, 只有通过的才是真正的 pk, 否则就是 hacker 的 pk’</p><p>首先 CA 有公钥和私钥, 我们管它们叫 cpk &amp; csk</p><p>然后 S 也有公私钥 pk &amp; sk</p><p>CA 把使用 csk 加密过的 pk 办法给 S, 我们称之为 licence(lic)(证书)</p><p>C 就不请求 pk 了, 而是向 S 请求 lic</p><p>那么 C 只要得到了 cpk 就可以解密出原来的 pk 了(和非对称加密原理类似)</p><p>那么 C 向 CA 去获取 cpk 的过程中依旧有可能会被 hacker 拦截, 那么怎么办?</p><p>其实并不需要去找 CA 请求, 因为 cpk 早就存放在了 C 的操作系统中</p><blockquote><p>补充一下, hacker 也是可以拿到 pk 的, 因为 hacker 本身可以是 C</p></blockquote><p>再来看,  C 生成 num1 并使用 pk 加密, 假如这时 hacker 变成了中间人</p><p>C 向 hacker 发送加密后的 y, 因为 hacker 只有 pk 所以不能解密, 也就对 y 无能为力, 更不能解密过程中的任何数据</p><hr><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><hr><p>这里我们以访问 bilibili 为例</p><ol><li><p>小明向 bilibili 发送请求, 请求中包含的数据有 “本机支持的SSL版本”、”非对称算法”、”num1”</p></li><li><p>bilibili 知道了请求, 把 “要使用的SSL版本”、”对称算法”、”num2”定了下来, 和 lic 一起打包发送给小明</p></li><li><p>小明去认证 bilibili 发送来的 lic, 如果真实有效则继续, 否则终止(或浏览器提示证书有问题)</p></li><li><p>小明向 bilibili 发送数据, 包含 “num3”、”使用hash加密后的1和2步的所有数据(假如是xx)”</p></li><li><p>bilibili 验证 xx 是否等于 hash(1, 2), 如果不等于代表是 hacker 上传的数据, bilibili 如果验证是小明本人, 则把 num1、num2和num3 生成一个 k</p></li><li><p>bilibili 向小明发送数据 hash(1, 2, 4)(假如是zz)</p></li><li><p>因为小明参与了之前的交互，所以可以验证 zz 是否是 hash(1, 2, 4), 如果是, 小明也使用 num1、num2和num3 生成一个 k, 因为算法一致, 小明的k 和 bilibili的k 应该是一致的</p></li></ol><p>至此协商过程完毕, 双方可以放心进行数据传输</p><hr>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令：git-stash</title>
      <link href="posts/328cd509.html"/>
      <url>posts/328cd509.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>git</code>是用来管理代码和工作流的强大工具,它以<code>commit</code>为单位,低成本开辟分支等优势备受青睐.<br>在实际开发中,我们常常遇到一些复杂的应用场景,不单单是<code>pull</code>,<code>commit</code>,<code>push</code>就能解决.下面我们通过引入<code>git stash</code>的使用,来讨论在复杂情况下<code>git</code>发挥的强大功能.</p><h2 id="git-stash-的作用"><a href="#git-stash-的作用" class="headerlink" title="git stash 的作用"></a>git stash 的作用</h2><p><code>git stash</code>用于想要保存当前的修改,但是想回到之前最后一次提交的干净的工作仓库时进行的操作.<code>git stash</code>将本地的修改保存起来,并且将当前代码切换到<code>HEAD</code>提交上.</p><p>通过<code>git stash</code>存储的修改列表,可以通过<code>git stash list</code>查看.<code>git stash show</code>用于校验,<code>git stash apply</code>用于重新存储.直接执行<code>git stash</code>等同于<code>git stash save</code>.</p><p>最新的存储保存在<code>refs/stash</code>中.老的存储可以通过相关的参数获得,例如<code>stash@&#123;0&#125;</code>获取最新的存储,<code>stash@&#123;1&#125;</code>获取次新.<code>stash@&#123;2.hour.ago&#125;</code>获取两小时之前的.存储可以直接通过索引的位置来获得<code>stash@&#123;n&#125;</code>.</p><h2 id="git-stash的概念理解"><a href="#git-stash的概念理解" class="headerlink" title="git stash的概念理解"></a>git stash的概念理解</h2><p><code>git stash</code>的每个存储单元在工作仓库中是通过<code>commit</code>的形式由树结构展示的.它的根节点是<code>HEAD</code>所在的提交.以下图标来表示<code>stash</code>和<code>branch</code>的关系.</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/04/09/yYeQjaw1DIX3poM.png"></p><p><code>H</code>是<code>HEAD</code>提交.<code>I</code>是存储单元的提交.<code>W</code>是工作树中的提交.</p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>通过几个实际的示例来了解一下<code>git stash</code>的强大.</p><blockquote><p><strong>开发到一半,同步远端代码</strong><br>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决.但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改.</p></blockquote><p>遇到这种情况,需要先保存本地的代码,进行<code>git pull</code>,然后再<code>pop</code>出本地代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git pull</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><blockquote><p><strong>工作流被打断,需要先做别的需求</strong><br>当开发进行到一半,老板过来跟你说 线上有个<code>bug</code>,你现在给我改好,不然扣你鸡腿”.当然,你可以开一个新的分支,把当前代码提交过去,回头再<code>merge</code>,具体代码如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 繁琐的工作流示例</span><br><span class="line"># ... hack hack hack ...</span><br><span class="line"> git checkout -b my_wip</span><br><span class="line"> git commit -a -m &quot;WIP&quot;</span><br><span class="line"> git checkout master</span><br><span class="line"> edit emergency fix</span><br><span class="line"> git commit -a -m &quot;Fix in a hurry&quot;</span><br><span class="line"> git checkout my_wip</span><br><span class="line"> git reset --soft HEAD^</span><br><span class="line"># ... continue hacking ...</span><br></pre></td></tr></table></figure><p>我们可以通过<code>git stash</code>来简化这个流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正确姿势</span><br><span class="line"># ... hack hack hack ...</span><br><span class="line"> git stash        &#x2F;&#x2F;保存开发到一半的代码</span><br><span class="line"> edit emergency fix</span><br><span class="line"> git commit -a -m &quot;Fix in a hurry&quot;</span><br><span class="line"> git stash pop   &#x2F;&#x2F;将代码追加到最新的提交之后</span><br><span class="line"># ... continue hacking ...</span><br></pre></td></tr></table></figure><blockquote><p><strong>提交特定文件</strong><br>如果对多个文件做了修改,但是只想提交几个文件,或者想先暂时保存几个修改,测试其他文件的执行结果.可以通过<code>git stash save --keep-index</code>来进行.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ... hack hack hack ...</span><br><span class="line"> git add --patch foo            &#x2F;&#x2F;只将第一部分加入管理the index</span><br><span class="line"> git stash save --keep-index   &#x2F;&#x2F;将其余部分保存起来</span><br><span class="line"> edit&#x2F;build&#x2F;test first part</span><br><span class="line"> git commit -m &#39;First part&#39;    &#x2F;&#x2F;提交全部的git管理中的代码</span><br><span class="line"> git stash pop                  &#x2F;&#x2F;继续进行存储代码的工作</span><br><span class="line"># ... repeat above five steps until one commit remains ...</span><br><span class="line"> edit&#x2F;build&#x2F;test remaining parts</span><br><span class="line"> git commit foo -m &#39;Remaining parts&#39;</span><br></pre></td></tr></table></figure><blockquote><p><strong>恢复被错误<code>clear/drop</code>的存储</strong></p></blockquote><p>如果因为失误对存储仓库进行了<code>clear</code>或者<code>drop</code>操作,在一般机制下是不能恢复的.但是可以通过以下指令来获取仍在仓库中的,但是已经不可获取的存储列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fsck --unreachable |</span><br><span class="line">grep commit | cut -d\  -f3 |</span><br><span class="line">xargs git log --merges --no-walk --grep&#x3D;WIP</span><br></pre></td></tr></table></figure><h2 id="git-stash-的具体用法"><a href="#git-stash-的具体用法" class="headerlink" title="git stash 的具体用法"></a>git stash 的具体用法</h2><p><code>git stash</code>通过在指令后添加其他的附件选项,实现复杂的定制化操作,下面我们来对具体用法进行讲解.</p><p><strong>save, push</strong></p><ul><li><code>save [-p|--patch] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [&lt;message&gt;]</code></li><li><code>push [-p|--patch] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [-m|--message &lt;message&gt;] [--] [&lt;pathspec&gt;…​]</code></li></ul><p><code>save</code>和<code>push</code>命令都可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上.后面的<code>&lt;message&gt;</code>是选填项.</p><p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储</p><p><code>--keep-index</code>(简写为<code>-k</code>)只会存储为加入<code>git</code>管理的文件</p><p><code>--include-untracked</code>为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态.如果不使用<code>--include-untracked</code>而是用<code>--all</code>,那么除了未加入管理的文件,被<code>git</code>忽略<code>(ignore)</code>的文件也会被缓存.</p><p><code>--patch</code>命令可以让我们选择当前修改和<code>HEAD</code>提交<code>diff</code>部分.</p><p><strong>list</strong></p><p><code>list [&lt;options&gt;]</code>展示当前存储库中的存储单元列表.每个元素包含的信息有索引位置,存储时所在的分支,存储前的提交的描述.举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on submit: 6ebd0e2... Update git-stash documentation</span><br><span class="line">stash@&#123;1&#125;: On master: 9cc0589... Add git-stash</span><br></pre></td></tr></table></figure><p><strong>show</strong></p><p><code>show [&lt;stash&gt;]</code>展示存储单元和最新提交的diff结果.如果没有给定<code>&lt;stash&gt;</code>参数时,会对比最新的存储单元.</p><p><strong>pop</strong></p><p><code>pop [--index] [-q|--quiet] [&lt;stash&gt;]</code>移除单个存储单元.和<code>git stash save</code>的作用相反.</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你为什么需要OLED?</title>
      <link href="posts/68da90b7.html"/>
      <url>posts/68da90b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OLED 是最近厂商宣传自家新品手机肯定会说到的一个词，那么到底什么是 OLED? 它的原理又是什么?</p><p>OLED 是个简称，全称为 Organic Light-Emitting Diode ，中文叫有机自发光二级管，又叫有机电激发光显示，是由法国人和美国人在 1950 ~ 1960 年左右研发出的一种新型显示技术，并在之后由美国柯达和英国剑桥大学加以研究，最后在 21 世纪被日本的索尼，韩国的三星、LG，中国的华星光电等公司批量生产</p><p>OLED 显示器依驱动方式的不同又可分为被动式（Passive Matrix，PMOLED）与主动式（Active Matrix，AMOLED）</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>OLED 基本结构是由一薄而透明具半导体特性之铟锡氧化物（ITO），与电力之正极相连，再加上另一个金属阴极，包成如三明治的结构。整个结构层中包括了：电洞传输层（HTL）、发光层（EL）与电子传输层（ETL）。当电力供应至适当电压时，阳极电洞与阴极电子便会在发光层中结合，产生光子，依其材料特性不同，产生红、绿和蓝三原色，构成基本色彩。OLED的特性是自发光，不像薄膜晶体管液晶显示器需要背光，因此可视度和亮度均高，且无视角问题，其次是驱动电压低且省电效率高，加上反应快、重量轻、厚度薄，构造简单，成本低等，被视为 21 世纪最具前途的产品之一</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/03/16/SKGTrILhvONekQR.png"></p><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><p>Wikipedia 上对 OLED 的特色介绍</p><ul><li>OLED 核心可以做得很薄，厚度为目前液晶的 1/3，加上有机发光半导体为全固态组件，抗震性好，能适应恶劣环境</li><li>OLED 主要是自体发光的，让其几乎没有视角问题；与 LCD 技术相比，即使在大的角度观看，显示画面依然清晰可见。OLED 的组件为自发光且是依靠电压来调整，反应速度要比液芯片件来得快许多，比较适合当作高清电视使用。2007 年底 SONY 推出的 11 吋 有机发光半导体电视 XEL-1 ，反应速度就比 LCD 快了 1000 倍</li><li>OLED 对低温的适应能力强。旧有的液晶技术在零下75度时，即会破裂故障，有机发光半导体只要电路未受损仍能正常显示</li><li>OLED 的效率高，耗能较液晶略低还可以在不同材质的基板上制造，甚至能成制作成可弯曲的显示器(例如曲面屏手机)，应用范围日渐增广</li><li>OLED 可以再屏幕下方塞下一些元器件，比如指纹识别模块（屏下指纹），摄像头（屏下摄像头）等</li></ul><p>说到底，你为什么需要 OLED? OLED 对比 LCD 又有哪些强项?</p><h2 id="LCD-简介"><a href="#LCD-简介" class="headerlink" title="LCD 简介"></a>LCD 简介</h2><p>LCD 也是简称，全称为 liquid-crystal display，中文液晶显示器，LCD 相比 其它显示器也很省电，但和 OLED 根本就不是一个级别的，LCD 的工作原理和 OLED 大不相同，OLED 是可以单独控制每个像素的发光进行合成颜色，而 LCD 是在底部放上一层背光板，在上方放上偏光片和彩色(Red Green Blue)滤色片，通过改变电压调节背光板亮度，和改变颜色滤色片的打开关闭程度来合成颜色</p><h2 id="LCD-vs-OLED"><a href="#LCD-vs-OLED" class="headerlink" title="LCD vs. OLED"></a>LCD vs. OLED</h2><p>因为 OLED 和 LCD 的工作原理大相迳庭，所以导致了这两种显示方式有很大的差距，比如：</p><ul><li>OLED 比 LCD 屏幕的响应时间小，可以控制在 1ms 以内，甚至可以是 LCD 的千分之一</li><li>OLED 控制的是每个像素的发光，也就是说，黑色就可以显示为纯黑色（不发光），而 LCD 只要有一个像素点显示就要打开背光，当然现在有些最新的技术，就是把 LCD 底部的背光板分割成很多区块，控制每个区块的发光，不过肯定还是比不上 OLED 的控制每个像素，这也间接导致了 OLED 比 LCD 省电</li><li>OLED 的厚度可以做得很小、很轻，因此同体积的手机，使用 OLED 的可以再手机机身里塞下更多东西，重量反而更轻，而 LCD 不行</li><li>OLED 内部是固体结构，相比 LCD 的液晶，会更抗摔一些</li><li>OLED 会比 LCD 更耐低温、耐高温一些</li><li>OLED 能在不同材质的基板上制作，可以弯曲，也就有了现在的曲面屏手机，而 LCD 只能做直屏</li><li>OLED 因为工作原理，所以对比度要远远高于 LCD</li><li>OLED 的 HDR 效果很好，因为其可以控制局部亮度，使整体显示效果相比 LCD 有很大提升，不过这也仅仅限于显示 HDR 内容时</li></ul><p>不过 LCD 也不完全没有优点，优点还是有的，比如：</p><ul><li>LCD 不会烧屏，因为他的显示原理和 OLED 恰恰相反，OLED “烧屏” 是因为在显示了一个静止图像很长时间后留在屏幕上的残影，而这个残影是无法消除的，而 LCD 就不会有这个烦恼，因为他不管显示什么，都是由彩色滤色片控制的，和背光板没有联系</li><li>LCD 不会频闪，因为他使用 DC 调光方式，而 OLED 的调光方式是 PWM 调光，就是通过快速亮灭来调节屏幕的亮度，所以会频闪严重，虽然现在 OLED 也有所谓的 “DC 调光”，不过那只是厂家的宣传方式手段之一，只不过是通过硬件或算法的方式让屏幕亮灭速度更快来达到 “DC 调光” 的效果罢了</li><li>LCD 的分辨率可以做得很高，因为每个彩色滤色片可以做得很小</li><li>LCD 的功耗比 OLED 低</li><li>LCD 的色彩还原十分准确</li><li>LCD 的寿命长，彩色滤光片几乎不会损坏，而背光板也可以更换</li><li>LCD 的造价便宜，成本低，导致了 OLED 屏幕手机普遍要比 LCD 的贵</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，两种显示方式各有自己的优缺点，而 OLED 才是「下一代」显示方式对比 LCD 有很大的潜力可以被发掘，也因为曲面屏的普及，LCD 在日常生活中的应用也渐渐地少了起来，若 OLED 能吸收 LCD 的优点，取长补短，必会普及到生活中的其他地方，而不仅仅限于手机、平版电脑、电视上</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 0.1 + 0.2 不等于 0.3?</title>
      <link href="posts/ffeccec5.html"/>
      <url>posts/ffeccec5.html</url>
      
        <content type="html"><![CDATA[<h2 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h2><p>你使用的编程语言并不烂，它能够做浮点数运算，但是计算机天生只能存储整数，因此它需要某种方法来表示小数，这种表示方式会带来某种程度的误差，这就是为什么往往 <code>0.1 + 0.2</code> 不等于 <code>0.3</code></p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么?"></a>为什么?</h2><p>实际上很简单：</p><p>对于十进制数值系统，它只能表示以进制数的质因子为分母的分数：<br>    <code>10</code> 的质因子有 <code>2</code> 和 <code>5</code>。因此 $\frac{1}{2}$、$\frac{1}{4}$、$\frac{1}{5}$、$\frac{1}{8}$ 和 $\frac{1}{10}$ 都可以精确表示，因为这些分母只使用了10的质因子。相反，$\frac{1}{3}$、$\frac{1}{6}$ 和 $\frac{1}{7}$ 都是循环小数，因为它们的分母使用了质因子 <code>3</code> 或者 <code>7</code>。<br>    二进制下，只有一个质因子，即 <code>2</code>。因此你只能精确表示分母质因子是 <code>2</code> 的分数。二进制中，$\frac{1}{2}$、$\frac{1}{4}$ 和 $\frac{1}{8}$ 都可以被精确表示。但是，$\frac{1}{5}$ 或者 $\frac{1}{10}$ 就变成了循环小数。所以，在十进制中能够精确表示的 <code>0.1</code> 与 <code>0.2</code>（$\frac{1}{10}$ 与 $\frac{1}{5}$），到了计算机所使用的二进制数值系统中，就变成了循环小数。当你对这些循环小数进行数学运算时，并将二进制数据转换成人类可读的十进制数据时，会对小数尾部进行截断处理</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>举个最简单的例子，在 Javascript(大部分编程语言) 中 计算 $0.1 + 0.2$ 会等于 $0.30000000000000004$</p><blockquote><p>在 JS 中数字采用的 IEEE 754 的双精度标准进行存储</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>想要解决也不是不行，因为计算机存储整数很好运算，所以只要把浮点数转换成整数即可，这里我贴一段 dalao 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accAdd = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    num1 = <span class="built_in">Number</span>(num1);</span><br><span class="line">    num2 = <span class="built_in">Number</span>(num2);</span><br><span class="line">    <span class="keyword">var</span> dec1, dec2, times;</span><br><span class="line">    <span class="keyword">try</span> &#123; dec1 = countDecimals(num1)+<span class="number">1</span>; &#125; <span class="keyword">catch</span> (e) &#123; dec1 = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; dec2 = countDecimals(num2)+<span class="number">1</span>; &#125; <span class="keyword">catch</span> (e) &#123; dec2 = <span class="number">0</span>; &#125;</span><br><span class="line">    times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(dec1, dec2));</span><br><span class="line">    <span class="comment">// var result = (num1 * times + num2 * times) / times;</span></span><br><span class="line">    <span class="keyword">var</span> result = (accMul(num1, times) + accMul(num2, times)) / times;</span><br><span class="line">    <span class="keyword">return</span> getCorrectResult(<span class="string">&quot;add&quot;</span>, num1, num2, result);</span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> accSub = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    num1 = <span class="built_in">Number</span>(num1);</span><br><span class="line">    num2 = <span class="built_in">Number</span>(num2);</span><br><span class="line">    <span class="keyword">var</span> dec1, dec2, times;</span><br><span class="line">    <span class="keyword">try</span> &#123; dec1 = countDecimals(num1)+<span class="number">1</span>; &#125; <span class="keyword">catch</span> (e) &#123; dec1 = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; dec2 = countDecimals(num2)+<span class="number">1</span>; &#125; <span class="keyword">catch</span> (e) &#123; dec2 = <span class="number">0</span>; &#125;</span><br><span class="line">    times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(dec1, dec2));</span><br><span class="line">    <span class="comment">// var result = Number(((num1 * times - num2 * times) / times);</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">Number</span>((accMul(num1, times) - accMul(num2, times)) / times);</span><br><span class="line">    <span class="keyword">return</span> getCorrectResult(<span class="string">&quot;sub&quot;</span>, num1, num2, result);</span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> accDiv = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    num1 = <span class="built_in">Number</span>(num1);</span><br><span class="line">    num2 = <span class="built_in">Number</span>(num2);</span><br><span class="line">    <span class="keyword">var</span> t1 = <span class="number">0</span>, t2 = <span class="number">0</span>, dec1, dec2;</span><br><span class="line">    <span class="keyword">try</span> &#123; t1 = countDecimals(num1); &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; t2 = countDecimals(num2); &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">    dec1 = convertToInt(num1);</span><br><span class="line">    dec2 = convertToInt(num2);</span><br><span class="line">    <span class="keyword">var</span> result = accMul((dec1 / dec2), <span class="built_in">Math</span>.pow(<span class="number">10</span>, t2 - t1));</span><br><span class="line">    <span class="keyword">return</span> getCorrectResult(<span class="string">&quot;div&quot;</span>, num1, num2, result);</span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> accMul = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    num1 = <span class="built_in">Number</span>(num1);</span><br><span class="line">    num2 = <span class="built_in">Number</span>(num2);</span><br><span class="line">    <span class="keyword">var</span> times = <span class="number">0</span>, s1 = num1.toString(), s2 = num2.toString();</span><br><span class="line">    <span class="keyword">try</span> &#123; times += countDecimals(s1); &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; times += countDecimals(s2); &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">    <span class="keyword">var</span> result = convertToInt(s1) * convertToInt(s2) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, times);</span><br><span class="line">    <span class="keyword">return</span> getCorrectResult(<span class="string">&quot;mul&quot;</span>, num1, num2, result);</span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> countDecimals = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num = <span class="built_in">Number</span>(num);</span><br><span class="line">        <span class="keyword">var</span> str = num.toString().toUpperCase();</span><br><span class="line">        <span class="keyword">if</span> (str.split(<span class="string">&#x27;E&#x27;</span>).length === <span class="number">2</span>) &#123; <span class="comment">// scientific notation</span></span><br><span class="line">            <span class="keyword">var</span> isDecimal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (str.split(<span class="string">&#x27;.&#x27;</span>).length === <span class="number">2</span>) &#123;</span><br><span class="line">                str = str.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">parseInt</span>(str.split(<span class="string">&#x27;E&#x27;</span>)[<span class="number">0</span>]) !== <span class="number">0</span>) &#123;</span><br><span class="line">                    isDecimal = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> x = str.split(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (isDecimal) &#123;</span><br><span class="line">                len = x[<span class="number">0</span>].length;</span><br><span class="line">            &#125;</span><br><span class="line">            len -= <span class="built_in">parseInt</span>(x[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.split(<span class="string">&#x27;.&#x27;</span>).length === <span class="number">2</span>) &#123; <span class="comment">// decimal</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">parseInt</span>(str.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>]) !== <span class="number">0</span>) &#123;</span><br><span class="line">                len = str.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>].length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(len) || len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> convertToInt = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num = <span class="built_in">Number</span>(num);</span><br><span class="line">    <span class="keyword">var</span> newNum = num;</span><br><span class="line">    <span class="keyword">var</span> times = countDecimals(num);</span><br><span class="line">    <span class="keyword">var</span> temp_num = num.toString().toUpperCase();</span><br><span class="line">    <span class="keyword">if</span> (temp_num.split(<span class="string">&#x27;E&#x27;</span>).length === <span class="number">2</span>) &#123;</span><br><span class="line">        newNum = <span class="built_in">Math</span>.round(num * <span class="built_in">Math</span>.pow(<span class="number">10</span>, times));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNum = <span class="built_in">Number</span>(temp_num.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNum;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> getCorrectResult = <span class="function"><span class="keyword">function</span>(<span class="params">type, num1, num2, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp_result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">            temp_result = num1 + num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;sub&quot;</span>:</span><br><span class="line">            temp_result = num1 - num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;div&quot;</span>:</span><br><span class="line">            temp_result = num1 / num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;mul&quot;</span>:</span><br><span class="line">            temp_result = num1 * num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(result - temp_result) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> temp_result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dalao 把四则运算封装成了函数，直接使用即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">加法: accAdd(<span class="number">0.1</span>, <span class="number">0.2</span>)  <span class="comment">// 得到结果：0.3</span></span><br><span class="line">减法: accSub(<span class="number">1</span>, <span class="number">0.9</span>)    <span class="comment">// 得到结果：0.1</span></span><br><span class="line">除法: accDiv(<span class="number">2.2</span>, <span class="number">100</span>)  <span class="comment">// 得到结果：0.022</span></span><br><span class="line">乘法: accMul(<span class="number">7</span>, <span class="number">0.8</span>)    <span class="comment">// 得到结果：5.6</span></span><br><span class="line"></span><br><span class="line">countDecimals()<span class="comment">//方法：计算小数位的长度</span></span><br><span class="line">convertToInt()<span class="comment">//方法：将小数转成整数</span></span><br><span class="line">getCorrectResult()<span class="comment">//方法：确认我们的计算结果无误，以防万一</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，Android 11 | 你好，Android 12</title>
      <link href="posts/85b78ca.html"/>
      <url>posts/85b78ca.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近几天因为买了新手机，再加上过年和开学等各种麻烦事儿，就没更新，说声抱歉<br>从今天开始应该会恢复更新的频率了，当然万不得已我会在留言版做公告</p></blockquote><blockquote><p>本文作者<a href="https://sspai.com/u/safari_cheung/updates">黎明前线Alan</a> &amp; <a href="https://sspai.com/u/clyde/updates">Clyde</a>，转载自<a href="https://sspai.com/post/65137">少数派</a>，转载时有改动</p></blockquote><hr><p>Android 11 还没捂热乎呢，这不，Android 12 Developer Preview 1 就出来了，不得不说 Google 对自己干儿子 (不会有人不知道 Android 是 Google 收购来的吧) 真是关怀备至<del>(不是)</del>，看这更新速度，有望在2023下半年赶上 iOS 版本号<del>(不是)</del></p><p>不到半年 (163天) 就更新的系统，到底啥来路？</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>和去年的 Android 11 一样，本次 Android 12 正式版发布前依然会在接下来的半年多时间里以每月 1 次的更新频率先后放出 3 个开发者预览版和 4 个 Beta 测试版，其中 5 月的首个测试版预计将在今年的 I/O 大会后同步放出，届时 Android 12 的 <a href="https://www.google.com/android/beta">Beta 测试项目</a> 应该也会上线</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/1fHoGtQNSBlvZ5w.png"></p><p>别灰心，虽然 Beta 测试项目 还没上线，<strong>部分</strong> Pixel 用户还可以通过手动刷入 开发者预览版镜像来体验 Android 12，这次符合测试的 Pixel 设备有以下这些:</p><ul><li>Pixel 3 / 3 XL</li><li>Pixel 3a / 3a XL</li><li>Pixel 4 / 4 XL</li><li>Pixel 4a / 4a 5G</li><li>Pixel 5</li></ul><p>~~ Pixel 2 用户枯了 ~~</p><blockquote><p><a href="https://developer.android.google.cn/about/versions/12/get">下载镜像</a></p></blockquote><p>你要是没有 Pixel 设备，那就得在等亿下了，毕竟 正式版 还没出来，国内厂商适配 Android 12 就是天方夜谭</p><p>但是没有 Pixel 也不能乱脑补，下面介绍下 Android 12 到底更新了什么</p><blockquote><p>正式版秋季应该就会放出</p></blockquote><hr><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>相信对 Android 感兴趣的童鞋，在很早之前就应该看过关于 Android 12 的图</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/vbwoHxV4Kcs2lWE.png"></p><p>然鹅 Android 12 DP 1 长这样: </p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/J1z7nYMAouSeQ5K.png"></p><p>Android 12 DP1 中大量系统界面都换上了一层浅蓝色背景，与 Pixel 默认的蓝色主题相呼应，覆盖界面包括所有二级系统设置界面、快速设置开关按钮、生物信息识别弹窗等等。不过目前这个配色还无法像已曝光截图那样根据壁纸进行取色，在「样式与壁纸」设置中更改系统配色也无法对其造成影响</p><p>另外系统桌面加入了 4 × 5 网格排列方式，除此之外界面功能定制和 Android 11 差不太多，主题定制的相关选项可能要到 5 月的 Beta 版才会放出</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/pwqDxAniYegh3EM.png"></p><p>设置界面，用户头像从搜索框中被单独拿了出来，并且拥有了更大的尺寸，功能上相比 Android 11 并没有任何变化</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/VawzHqAZYjs9c82.png"></p><p>(对比图统统为 左 Android 11 | 右 Android 12)</p><p>另外，在 DP 1 里还加入了几种新的开关控件样式，和 iOS 相比有异曲同工之妙</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/JHQEjGcwKV7mvPd.gif"></p><p>还有的是一些设置选项做了整合工作，比如注视亮屏的功能被移动到了屏幕超时选项下方，更符合索引和归类的逻辑，<del>这样在查找某选项时可以按着第一感觉盲点了</del> Wi-Fi 二维码分享下方也提供了就近分享，如果对方手机支持这个功能，就可以跳过扫二维码这个步骤直接连接 Wi-Fi </p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/jK3HELtCfYeQ7Vm.png"></p><hr><p>值得一提的是，Google 在 DP1 中其实还暗藏了一个全新的设置样式：使用 adb 命令即可为 DP1 的设置界面开启一个名为 Silky Home 的新版 UI：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global settings_silky_home true</span><br></pre></td></tr></table></figure><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/vXk4Ud9eBpnjsTu.png"></p><p>三星用户应该对这样的 UI 并不陌生，顶部标题做了大量的留白，加上更大的设置图标，看样子是为了让单手握持手机时更好操作，不过这一设计风格对 Google 而言也只停留在设置界面，毕竟 Google 自己亲儿子 (Google apps) 并没有对这种设计风格做任何的适配</p><p>暗色模式也有了小幅调整，更多组件的背景颜色由纯黑色变成了 Google 推荐使用的灰色 (#121212)，不过设置界面背景依然是纯黑</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/NZCt9uF6pIRQBrj.png"></p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>从界面到交互，自打 Android 10 以来，Google 就一直在对这套交互方式做各种小修小补，可以看到 Google 在让这套交互方式更加人性化</p><p>我们首先区分几个概念。在 Android 平台上，让应用全屏显示的方式（全屏模式）分为回调模式、沉浸模式和粘性沉浸模式三种，其中回调模式和沉浸模式对应的又可以被统称为非粘性沉浸模式：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/wuMPUnk5KTx8XNh.png"></p><p>其中非粘性沉浸模式的代表是 Google Photos，即当我们全屏查看照片时系统栏（主要是状态栏和手势横条）会自动隐藏，但我们可以随时通过点击、划动行为退出全屏；游戏玩家则对粘性沉浸模式更加熟悉，在这种全屏模式下，我们需要首先在屏幕边缘向内滑动一次呼出边缘的手势横条和顶部的状态栏，然后再滑动一次才能触发手势操作返回主屏</p><p>Android 10 引入的全面屏手势在非粘性沉浸模式下此前一直存在「连续性」问题，在上面的「使用 Google Photos 全屏查看照片」这一例子中，返回、回到主屏等高优先级操作需要进行两次划动才能触发</p><p>Android 12 DP1 就对非粘性模式下的手势操作进行了精简，具体而言：</p><ul><li>使用按键导航模式（即「三大金刚」）时，退出非粘性沉浸模式的视觉反馈和操作步骤都没有变化</li><li>使用全面屏手势时，系统可以在系统栏未被呼出的状态下直接响应手势操作，不管是返回、Home 还是下拉通知栏都只需要一次操作</li></ul><hr><p>除了全面屏手势，Google 也在 Android 12 DP1 中埋下了一些尚未正式上线的实验性交互功能</p><p>首先是背部敲击手势，这项去年曾经在 Android 11 代码中出现过的功能这次直接出现在了 Pixel 5 的手势设置当中，从设置项来看 Google 为 Pixel 手机的背部敲击手势准备了唤醒语音助理、控制媒体播放、截屏等诸多自定义操作，同时还提供了防误触设定（Require harder taps）</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/TGBF7io6fwJLMAH.png"></p><p>虽然功能有，但是开启后毫无作用，并且这项功能只会开放给 Pixel 5</p><p>另外，Google 似乎也在开发原生的「单手模式」。从 XDA 主编 Mishaal Rahman 开启相关隐藏功能后发布的 视频 来看，和目前 OEM 厂商普遍使用的缩放至屏幕边角的实现方式不同，Google 的单手操作模式更像是 iOS 那种下拉悬停</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/XcrbyHaLpFKJZVS.gif"></p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>对通知系统的改动几乎不会缺席历年的 Android 开发者测试版，本次 Android 12 DP1 也不例外</p><p><strong>首先是风格、布局都更加规范的通知样式</strong></p><p>用简洁点的语言来说就是 Android 12 会有一套新的 自定义通知界面 开发模板</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/fV1bEyM7OzKgZIR.png"></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/nVmsYUG48DTC9yz.png"></p><p>此前采用自定义通知模板构建通知的应用，在 Android 12 DP 1 下的消息推送其实已经可以自动适应新样式了（下图右）。相比 Android 11 新的自定义通知样式主体图片展示区域更大，各类操作按钮也遵循通知内容进行了对齐：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/SOryXlpDdAu7t3n.png"></p><p>其次，Android 系统自带的通知延后功能也更好用了。在原本左右滑动设置延后的基础上，Android 12 DP1 直接在通知卡片上添加了一个新的延后按钮（闹钟），让我们可以直接点击进行延后操作:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/fd85K9RaMmupzVP.png"></p><p>尽管已经在 Android 11 测试阶段经过多次修改、完善，Android 开发团队对媒体通知卡片还是有着更多的设计和想法。从媒体界面元素的设计上，Android 12 DP1 相比 Android 11 正式版除了卡片本身面积进一步变大之外，歌曲专辑封面也重新占据了卡片左侧近三分之一的面积，用于控制音频播放的按钮则来到了中间位置，与媒体信息靠左对齐:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/J8DRM52EQsAl3Vx.png"></p><p>而在通知栏中，Android 12 DP1 更是直接将媒体卡片的左右两侧填充至与通知栏对齐，进一步增加了媒体卡片的显示面积，加上因为控件元素大多左对齐留出的空白区域，Android 12 后续更新显然还需要对媒体卡片进行更多功能与设计上的打磨:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/iYBzHu4WInE9CVw.png"></p><p>Android 12 DP1 为媒体卡片引入了应用选择功能，我们可以在「设置 &gt; 提示音与震动 &gt; 媒体 &gt; 快捷设置中的媒体播放器」中选择可以显示在快捷设置面板媒体卡片中的应用；反之也可以让某些应用从媒体卡片的位置「隐身」:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/ygi5vfEjp1odHO4.png"></p><p>除了更规范的通知样式和媒体通知卡片调整，Android 12 DP1 也开始着力优化通知的视觉和交互体验</p><p>视觉层面，Android 用户或多或少都看到过「某某应用正在运行」这种通知，比如微信，如果我们没有为其开启「电池优化」，锁屏后其实偶尔可以观察到类似的通知出现并消失</p><p>Android 开发团队似乎也知道这类通知比较烦人，因此在 Android 12 DP1 引入了 <a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#foreground-service-notification-delay">前台服务通知延迟</a> 机制，顾名思义，一些定时出现且不会常驻的前台服务通知最多可以延迟 10 秒显示，因此如果相关前台任务在短时间内能够完成，便不会有任何通知出现</p><p>交互层面，Android 12 DP1 则进一步加快了通知操作响应速度。以往开发者常常会通过一个广播接收器或者服务作为「中介」，用来处理用户的通知操作行为并调起相应的活动窗口（这个「中介」的学名叫 notification trampolines）。问题这种方式其实非常低效，实际上我们也经常会遇到某些通知操作点击后需要响应半天的情况</p><p>Android 12 则建议开发者进行迁移，让通知操作直接与目标活动窗口建立响应机制来完成交互，以此实现更加快速的通知操作反馈</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/zW5faSshEiIBrjZ.png"></p><h3 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h3><p>即便 Android 设备的性能节节提升，面对带有样式的文本或图像、视频、音频等富媒体内容时，不同的应用之间还是很难像桌面操作系统那样高效、快速地完成内容复制与迁移。这也是近年仍在发力 Android 平板生态的华为、三星等厂商一直试图解决的问题</p><p>Google 则希望从系统层面提供更多灵活性。在 Android 12 DP1 中，新的 <a href="https://developer.android.google.cn/about/versions/12/features/unified-content-api">Unified API</a> 以及 UI 组件中新的接口让我们可以在应用间快速复制、粘贴富文本内容，甚至借助键盘快捷键实现近似桌面端的富文本复制粘贴体验</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/ceBRstPbST2Qm6X.gif"></p><p>同时，针对部分应用不支持特定的视频格式内容播放的问题，Android 12 也会借助 Project Mainline 模块升级加入<a href="https://developer.android.com/about/versions/12/features/compatible-media-transcoding">「兼容视频转码」（Compatible media transcoding）</a>功能：无论是 HEVC(H.265) 还是 HDR10/HDR10+ 格式，当应用打开不支持格式的视频文件时，Android 12 可以自动将 HEVC(H.265) 格式录制的视频转换为兼容性更强的 AVC(H.264) 格式，保证播放时的兼容性</p><p>与之对应的，在 USB 偏好设置中，Android 12 也加入了可以直接勾选开启的视频导出转码功能：当我们从手机中导出采用 HEVC(H.265) 编码格式拍摄的视频时，系统会先进行一次编码转换，让导出的视频变为兼容性更好的 AVC(H.264) 编码格式</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/DPsHKLCp4kvgSbw.png"></p><p>图像格式方面，Android 12 除了通过向 ImageDecoder 引入 GIF 与动态 WebP 图像解码能力外，还加入了对 AVIF 格式图像支持。如果你还不了解 AVIF 的话，它是一种基于视频编码格式 AV1 而来的图像编码格式，和当前主流的图像格式（比如 JPEG）相比， AVIF 最大的优势在于拥有更小的文件体积和更高的图像质量，同时没有复杂的专利授权问题</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/rfPE98aR4gFSxK2.png"></p><p>目前 Chrome 已经在 85 版本中加入了对 AVIF 格式的支持，而 Firefox 也已经在 84.0 版本中支持了这一功能，虽然 Safari 当前还尚未跟进，考虑到 Apple 本身也是 AV1 格式的制定机构，这一格式的推广和普及应该也只是时间问题。Android 12 这一次算是走在时代前沿了</p><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h3><p>去年的 MIUI 12 对隐私保护大刀阔斧，各位观众应该会有了解，再看 Android 12 的隐私保护，对比之下惨淡不少，改了这些地方:</p><ul><li>目标系统版本为 Android 12 的应用在后台运行时将无法再发起前台服务，参考 <a href="https://developer.android.google.cn/about/versions/12/foreground-services">🔗</a></li><li>运行在 Android 12 中的应用都无法获取设备的准确 MAC 地址，系统会向目标系统版本为 Android 12 的应用返回 null 值，向目标系统版本低于 Android 12 的应用返回固定值 02:00:00:00:00:00，参考 <a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#mac-address">🔗</a></li><li>限制高风险、安全性相关界面的触摸交互行为（避免点击劫持）<a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#untrusted-touch-events">🔗</a>，同时禁止应用关闭系统对话框 <a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all#close-system-dialogs">🔗</a></li></ul><p>相比之下，位于「系统设置 &gt; 安全和紧急情况」中的紧急求救功能倒是更加值得我们关注。该功能允许开启后，我们可以通过快速连按 5 次以上电源键来拨打紧急求救电话，我们也可以根据实际情况在设置中开启拨号前的警报声提醒 —— 最重要的是，这个功能会根据设备的地理位置自动设定紧急联系电话（比如国内默认为 110），比起之前大部分功能在国内都不可用的 Personal Safety 功能实用性有了大幅提升</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/IENm2j9nZblrfae.png"></p><p>最后，9to5Google 通过调查发现，Android 12 DP1 中还藏着一个隐藏的「隐私开关」功能，允许我们通过快速设置开关直接屏蔽相机和麦克风调用，达到模拟物理屏蔽硬件的效果。该功能目前并未正式上线</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/gSQ3BXwLaHmIxFY.png"></p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>市面上以「游戏」为卖点的 Android 设备越来越多，Google 自家云游戏服务 Stadia 的存在也让移动设备成为了游戏体验中不可或缺的一环</p><p>此前 Google 已经通过持续更新为 Android 平台带来了较为完备的游戏手柄支持，而根据 XDA 主编 Mishaal Rahman 的研究，Google 这次还在 Android 12 DP1 中埋入了针对游戏手柄的振动反馈支持，相关设置位于「语言与输入法」选项当中，暂未正式上线</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/QVCwY4bDkXoBPqx.png"></p><p>游戏方面同样值得注意的是，Android 12 DP1 也允许开发者根据音频生成对应的振动反馈，以此实现更加具有沉浸感的游戏体验。当然根据 Google 的官方文档，开发者同样可以利用这个 <a href="https://developer.android.google.cn/reference/android/media/audiofx/HapticGenerator">接口</a> 开发具备不同振动提醒方式的拨号应用，可以说是一个很有潜力的新特性</p><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>在 Android 11 开发和测试过程中就备受期待的长截图功能依然还没准备好。尽管相关功能已经整合到了 Android 12 DP1 当中，9to5Google 通过特殊手段开启后发现长截图功能目前还有诸多问题，比如仅能截取额外约一屏长度的内容、只对特定应用有效、无法处理好 FAB 按钮等</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/sI1qJHQM7a6zBt3.png"></p><p>常规的截图功能本身倒是又迎来了一次不小的更新</p><p>一方面，原本有些 BUG 的截图浮窗关闭方式得到了优化。Android 12 DP1 取消了截图浮窗上的关闭按钮，转而采用了向屏幕外划动这一手势来关闭浮窗的操作方式，符合直觉，同时也是目前 OEM 在定制系统中常常采用的做法</p><p>另一方面，截图标注工具新增了海量功能，除了基础的记号笔、橡皮擦和裁剪工具，新加入的荧光笔、文本、emoji 表情也能进一步满足我们进行截图标注时的不同需求</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/24/8tSfAUzRrVliL5a.png"></p><p>除此之外，Android 12 DP1 还为 Pixel 5 补上了「隐藏屏幕开孔」选项、增强了 Wi-Fi Aware 的相关特性并新增了一个用于减少色彩亮度、帮助视障人士使用的 Reduce Bright Colors 功能，可通过快速设置开关进行开启</p><hr><p>以上便是 Android 12 DP 1 的大部分更新内容，当然还会有很多小细节没有被发现，新的细节被发现时，会在该文章继续更新（大概）</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aplayer的基础教程</title>
      <link href="posts/29a4d9de.html"/>
      <url>posts/29a4d9de.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>🍭 Wow, such a beautiful HTML5 music player</p></blockquote><p><a href="https://aplayer.js.org/#/zh-Hans/">APlayer</a> 是采用 MIT 许可的开源项目，它是一个智能的音乐播放器</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 HTML 中写入:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;[APlayer.min.css]&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;aplayer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;[APlayer.min.js]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 JS 中写入: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> APlayer(&#123;</span><br><span class="line">    container: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;aplayer&#x27;</span>),</span><br><span class="line">    audio: [&#123;</span><br><span class="line">        name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        artist: <span class="string">&#x27;artist&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;url.mp3&#x27;</span>,</span><br><span class="line">        cover: <span class="string">&#x27;cover.jpg&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th>名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>container</td><td>document.querySelector(‘.aplayer’)</td><td>播放器容器元素</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>fixed</td><td>false</td><td>开启吸底模式</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>mini</td><td>false</td><td>开启迷你模式</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>autoplay</td><td>false</td><td>音频自动播放</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>theme</td><td>‘#b7daff’</td><td>主题色</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>loop</td><td>‘all’</td><td>音频循环播放, 可选值: ‘all’, ‘one’, ‘none’</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>order</td><td>‘list’</td><td>音频循环顺序, 可选值: ‘list’, ‘random’</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>preload</td><td>‘auto’</td><td>预加载，可选值: ‘none’, ‘metadata’, ‘auto’</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>volume</td><td>0.7</td><td>默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio</td><td>-</td><td>音频信息, 应该是一个对象或对象数组</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.name</td><td>-</td><td>音频名称</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.artist</td><td>-</td><td>音频艺术家</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.url</td><td>-</td><td>音频链接</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.cover</td><td>-</td><td>音频封面</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.lrc</td><td>-</td><td>-</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.theme</td><td>-</td><td>切换到此音频时的主题色，比上面的 theme 优先级高</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>audio.type</td><td>‘auto’</td><td>可选值: ‘auto’, ‘hls’, ‘normal’ 或其他自定义类型</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>customAudioType</td><td>-</td><td>自定义类型</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>mutex</td><td>true</td><td>互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>lrcType</td><td>0</td><td>歌词类型</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>listFolded</td><td>false</td><td>列表默认折叠</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>listMaxHeight</td><td>-</td><td>列表最大高度</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>storageName</td><td>‘aplayer-setting’</td><td>存储播放器设置的 localStorage key</td></tr></tbody></table><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> APlayer(&#123;</span><br><span class="line">    container: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;aplayer&#x27;</span>),</span><br><span class="line">    mini: <span class="literal">false</span>,</span><br><span class="line">    autoplay: <span class="literal">false</span>,</span><br><span class="line">    theme: <span class="string">&#x27;#FADFA3&#x27;</span>,</span><br><span class="line">    loop: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    order: <span class="string">&#x27;random&#x27;</span>,</span><br><span class="line">    preload: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line">    volume: <span class="number">0.7</span>,</span><br><span class="line">    mutex: <span class="literal">true</span>,</span><br><span class="line">    listFolded: <span class="literal">false</span>,</span><br><span class="line">    listMaxHeight: <span class="number">90</span>,</span><br><span class="line">    lrcType: <span class="number">3</span>,</span><br><span class="line">    audio: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&#x27;name1&#x27;</span>,</span><br><span class="line">            artist: <span class="string">&#x27;artist1&#x27;</span>,</span><br><span class="line">            url: <span class="string">&#x27;url1.mp3&#x27;</span>,</span><br><span class="line">            cover: <span class="string">&#x27;cover1.jpg&#x27;</span>,</span><br><span class="line">            lrc: <span class="string">&#x27;lrc1.lrc&#x27;</span>,</span><br><span class="line">            theme: <span class="string">&#x27;#ebd0c2&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&#x27;name2&#x27;</span>,</span><br><span class="line">            artist: <span class="string">&#x27;artist2&#x27;</span>,</span><br><span class="line">            url: <span class="string">&#x27;url2.mp3&#x27;</span>,</span><br><span class="line">            cover: <span class="string">&#x27;cover2.jpg&#x27;</span>,</span><br><span class="line">            lrc: <span class="string">&#x27;lrc2.lrc&#x27;</span>,</span><br><span class="line">            theme: <span class="string">&#x27;#46718b&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用MetingJS"><a href="#使用MetingJS" class="headerlink" title="使用MetingJS"></a>使用MetingJS</h3><p>如果你觉得上面的一个一个音频设置过于麻烦，还可以使用 MetingJS</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入 APlayer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 导入 MetingJS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;meting-js</span><br><span class="line">server=&quot;netease&quot;</span><br><span class="line">type=&quot;playlist&quot;</span><br><span class="line">id=&quot;number&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">meting-js</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的导入相信大家都看的懂，下面的标签大概意思是从音乐网站导入歌单</p><p>server: <strong>音乐网站</strong>，MetingJS目前支持 ‘netease’, ‘tencent’, ‘xiami’<br>type: song, playlist, album, search, artist<br>id: 歌曲、歌单的 ID</p><h3 id="MetingJS-使用举例"><a href="#MetingJS-使用举例" class="headerlink" title="MetingJS 使用举例"></a>MetingJS 使用举例</h3><p>如果你想和我一样，在音乐室中加入网易云音乐热歌榜，可以像我这样写👇</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meting-js</span><br><span class="line">server=&quot;netease&quot;</span><br><span class="line">type=&quot;playlist&quot;</span><br><span class="line">id=&quot;3778678&quot;&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">meting-js</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网易云的热歌榜上写的类型是toplist，但实际也是一个playlist，其ID为3778678，每周四更新，ID不变 --&gt;</span></span><br></pre></td></tr></table></figure><p>MetingJS 还会对有歌词的音乐自动添加歌词在Aplayer中</p><hr><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul><li>Aplayer.min.css<ul><li><code>https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css</code></li></ul></li><li>Aplayer.min.js<ul><li><code>https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js</code></li></ul></li><li>Meting.min.js<ul><li><code>https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换Linux系统更新源</title>
      <link href="posts/907e32be.html"/>
      <url>posts/907e32be.html</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Linux、类Linux系统都是用叫做 <strong>Package Manager</strong> 用来管理软件包的，这里我以<strong>Ubuntu 18.04</strong>为例介绍一下如何使用命令来安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install pk-name</span><br></pre></td></tr></table></figure><p>随便安装一个软件包，会发现速度不是很慢就是根本连接失败，那难道就没有别的办法了吗？</p><hr><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>其实，我们可以对系统进行切换源操作，图形界面的Ubuntu在设置里会自带切换源的方式，不过命令行就需要手动切换了👇</p><p>系统里有一个文件用来专门处理软件源的，我们首先复制该文件，命令如下👇</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>接下来我们使用文本编辑器将其修改，这里推荐使用nano编辑器，可以通过<code>apt install nano</code>来安装，如果因为网络安装不了，也可以使用自带的<code>vim</code></p><p>删除原来的所有内容，将以下内容选择一个复制进去: </p><blockquote><p>⚠警告：下列软件源只适用于 Ubuntu 18.04，如因为版本使用错误等问题本人概不负责，可以自行尝试使用.bak还原</p></blockquote><h4 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h4 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>编辑好后保存退出，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>来更新软件源，这样就替换好啦</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么应该在Linux上使用命名管道</title>
      <link href="posts/e9d3402e.html"/>
      <url>posts/e9d3402e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者<a href="https://www.zhihu.com/org/linuxzhong-guo">Linux中国</a>，转载自<a href="https://zhuanlan.zhihu.com/p/33641576">知乎</a>，转载时有改动</p></blockquote><hr><blockquote><p>命名管道并不常用，但是它们为进程间通讯提供了一些有趣的特性</p></blockquote><p>看了上一篇文章后，我估计每一位 Linux 使用者都熟悉使用 “|” 符号将数据从一个进程传输到另一个进程的操作。它使用户能简便地从一个命令输出数据到另一个命令，并筛选出想要的数据而无须写脚本进行选择、重新格式化等操作</p><p>还有另一种管道，虽然也叫 “管道” 这个名字却有着非常不同的性质。即您可能尚未使用甚至尚未知晓的 —— 命名管道</p><p>普通管道与命名管道的一个主要区别就是命名管道是以文件形式实实在在地存在于文件系统中的，没错，它们表现出来就是文件。但是与其它文件不同的是，命名管道文件似乎从来没有文件内容。即使用户往命名管道中写入大量数据，该文件看起来还是空的</p><h3 id="如何在-Linux-上创建命名管道"><a href="#如何在-Linux-上创建命名管道" class="headerlink" title="如何在 Linux 上创建命名管道"></a>如何在 Linux 上创建命名管道</h3><p>在我们研究这些空空如也的命名管道之前，先追根溯源来看看命名管道是如何被创建的。您应该使用名为 <code>mkfifo</code> 的命令来创建它们。为什么提及 “FIFO”? 是因为命名管道也被认为是一种 FIFO 特殊文件。术语 “FIFO” 指的是它的先进先出 first-in, first-out 特性。如果你将冰淇淋盛放到碟子中，然后可以品尝它，那么你执行的就是一个LIFO（后进先出 last-in, first-out 操作。如果你通过吸管喝奶昔，那你就在执行一个 FIFO 操作。好，接下来是一个创建命名管道的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo mypipe</span><br><span class="line">$ ls -l mypipe</span><br><span class="line">prw-r-----. 1 shs staff 0 Jan 31 13:59 mypipe</span><br></pre></td></tr></table></figure><p>注意一下特殊的文件类型标记 “p” 以及该文件大小为 0。您可以将重定向数据写入命名管道文件，而文件大小依然为 0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Can you read this?&quot;</span> &gt; mypipe</span><br></pre></td></tr></table></figure><p>正如上面所说，敲击回车后似乎什么都没有发生（LCTT 译注：没有返回命令行提示符）</p><p>另外再开一个终端，查看该命名管道的大小，依旧是 0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l mypipe</span><br><span class="line">prw-r-----. 1 shs staff 0 Jan 31 13:59 mypipe</span><br></pre></td></tr></table></figure><p>也许这有违直觉，用户输入的文本已经进入该命名管道，而你仍然卡在输入端。你或者其他人应该等在输出端，并准备读取放入管道的数据。现在让我们读取看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat mypipe</span><br><span class="line">Can you <span class="built_in">read</span> this?</span><br></pre></td></tr></table></figure><p>一旦被读取之后，管道中的内容就没有了。</p><p>另一种研究命名管道如何工作的方式是通过将放入数据的操作置入后台来执行两个操作（将数据放入管道，而在另外一段读取它）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Can you read this?&quot;</span> &gt; mypipe &amp;</span><br><span class="line">[1] 79302</span><br><span class="line">$ cat mypipe</span><br><span class="line">Can you <span class="built_in">read</span> this?</span><br><span class="line">[1]+ Done <span class="built_in">echo</span> <span class="string">&quot;Can you read this?&quot;</span> &gt; mypipe</span><br></pre></td></tr></table></figure><p>一旦管道被读取或”耗干”，该管道就清空了，尽管我们还能看见它并再次使用。可为什么要费此周折呢？</p><h3 id="为何要使用命名管道？"><a href="#为何要使用命名管道？" class="headerlink" title="为何要使用命名管道？"></a>为何要使用命名管道？</h3><p>命名管道很少被使用的理由似乎很充分。毕竟在 Unix 系统上，总有多种不同的方式完成同样的操作。有多种方式写文件、读文件、清空文件，尽管命名管道比它们来得更高效</p><p>值得注意的是，命名管道的内容驻留在内存中而不是被写到硬盘上。数据内容只有在输入输出端都打开时才会传送。用户可以在管道的输出端打开之前向管道多次写入。通过使用命名管道，用户可以创建一个进程写入管道并且另外一个进程读取管道的流程，而不用关心协调二者时间上的同步</p><p>用户可以创建一个单纯等待数据出现在管道输出端的进程，并在拿到输出数据后对其进行操作。下列命令我们采用 tail 来等待数据出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f mypipe</span><br></pre></td></tr></table></figure><p>一旦供给管道数据的进程结束了，我们就可以看到一些输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f mypipe</span><br><span class="line">Uranus replicated to WCDC7</span><br><span class="line">Saturn replicated to WCDC8</span><br><span class="line">Pluto replicated to WCDC9</span><br><span class="line">Server replication operation completed</span><br></pre></td></tr></table></figure><p>如果研究一下向命名管道写入的进程，用户也许会惊讶于它的资源消耗之少。在下面的 ps 命令输出中，唯一显著的资源消耗是虚拟内存（VSZ 那一列）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps u -P 80038</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">shs 80038 0.0 0.0 108488 764 pts/4 S 15:25 0:00 -bash</span><br></pre></td></tr></table></figure><p>命名管道与 Unix/Linux 系统上更常用的管道相比足以不同到拥有另一个名号，但是 “管道” 确实能反映出它们如何在进程间传送数据的形象，故将称其为”命名管道”还真是恰如其分。也许您在执行操作时就能从这个聪明的 Unix/Linux 特性中获益匪浅呢</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍Linux中的管道和命名管道</title>
      <link href="posts/8936c172.html"/>
      <url>posts/8936c172.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者<a href="https://www.zhihu.com/org/linuxzhong-guo">Linux中国</a>，转载自<a href="https://zhuanlan.zhihu.com/p/44181732">知乎</a>，转载时有改动</p></blockquote><hr><blockquote><p>要在命令间移动数据？使用管道可使此过程便捷</p></blockquote><p>在 Linux 中，pipe 能让你将一个命令的输出发送给另一个命令。管道，如它的名称那样，能重定向一个进程的标准输出、输入和错误到另一个进程，以便于进一步处理</p><p>“管道”（或称“未命名管道”）命令的语法是在两个命令之间加上 <code>|</code> 字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command-1 | Command-2 | ...| Command-N</span><br></pre></td></tr></table></figure><p>这里，该管道不能通过另一个会话访问；它被临时创建用于接收 <code>Command-1</code> 的执行并重定向标准输出。它在成功执行之后删除</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/01/mxLiDzw81euvpGJ.jpg"></p><p>在上面的示例中，contents.txt 包含特定目录中所有文件的列表 —— 具体来说，就是 <code>ls -al</code> 命令的输出。我们首先通过管道（如图所示）使用 “file” 关键字从 contents.txt 中 <code>grep</code> 文件名，因此 <code>cat</code> 命令的输出作为 <code>grep</code> 命令的输入提供。接下来，我们添加管道来执行 <code>awk</code> 命令，该命令显示 <code>grep</code> 命令的过滤输出中的第 9 列。我们还可以使用 <code>wc -l</code> 命令计算 contents.txt 中的行数</p><p>只要系统启动并运行或直到它被删除，命名管道就可以持续使用。它是一个遵循 <code>FIFO</code>（先进先出）机制的特殊文件。它可以像普通文件一样使用。也就是，你可以写入，从中读取，然后打开或关闭它。要创建命名管道，命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo &lt;pipe-name&gt;</span><br></pre></td></tr></table></figure><p>这将创建一个命名管道文件，它甚至可以在多个 shell 会话中使用</p><p>创建 <code>FIFO</code> 命名管道的另一种方法是使用此命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod p &lt;pipe-name&gt;</span><br></pre></td></tr></table></figure><p>要重定向任何命令的标准输出到其它命令，请使用 &gt; 符号。要重定向任何命令的标准输入，请使用 &lt; 符号</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/01/qwK3GD8b7QaizNe.png"></p><p>如上所示，<code>ls -al</code> 命令的输出被重定向到 contents.txt 并插入到文件中。类似地，tail 命令的输入通过 &lt; 符号从 contents.txt 读取</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/02/01/pBFTrVOWMcDljHY.png"></p><p>这里，我们创建了一个命名管道 my-named-pipe，并将 <code>ls -al</code> 命令的输出重定向到命名管道。我们可以打开一个新的 shell 会话并 <code>cat</code> 命名管道的内容，如前所述，它显示了 <code>ls -al</code> 命令的输出。请注意，命名管道的大小为零，并有一个标志 “p”</p><p>因此，下次你在 Linux 终端上使用命令并在命令之间移动数据时，希望管道使这个过程快速简便</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathJax基础语法</title>
      <link href="posts/4fa51aea.html"/>
      <url>posts/4fa51aea.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文简单易懂内容部分省略，防止文章过于冗长</p></blockquote><h2 id="什么是-Mathjax"><a href="#什么是-Mathjax" class="headerlink" title="什么是 Mathjax"></a>什么是 Mathjax</h2><p>MathJax 是一个开源，基于 Ajax 技术的数学表达式显示解决方案。它能够在 HTML 页面中高质量的显示 LaTeX 和 MathML 数学符号。支持大部分浏览器，不需要插件，额外字体或安装特殊的阅读器。支持复制 / 粘贴。如果浏览器支持 Mathml，则 MathJax 可以将 TeX 标记转换为 Mathml 语言，来加速渲染</p><p>MathJax 跟其他基于 LaTeX 的许多显示方案一样，不需要网页浏览者安装任何插件或者脚本，其最大的优势在于可以以基于文本的方式显示页面中的数学公式，支持几乎所有的主流浏览器。而且不管是 IE6+，Firefox3.0+，Chrome，Safari，还是其他任何千奇百怪的浏览器，都能够很好地渲染公式样式</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="编写位置"><a href="#编写位置" class="headerlink" title="编写位置"></a>编写位置</h3><ul><li><p>行内公式: 在行内用<code>$...$</code>包裹，中间编写公式<br>  语句: <code>$\sum_&#123;i=0&#125;^N\int_&#123;a&#125;^&#123;b&#125;g(t,i)\text&#123;d&#125;t$</code><br>  长这个亚子👉: $\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</p></li><li><p>块公式(反正我是这么叫): 在单独一行用<code>$$...$$</code>包裹，中间编写公式<br>  语句: <code>$$\sum_&#123;i=0&#125;^N\int_&#123;a&#125;^&#123;b&#125;g(t,i)\text&#123;d&#125;t$$</code></p></li></ul><p>长这个亚子👇</p><p>$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$</p><p>行内公式也可以显示成块公式的样式，须在公式前加入 <code>\displaystyle</code> 属性，如:</p><p><code>\displaystyle\sum_&#123;i=0&#125;^N\int_&#123;a&#125;^&#123;b&#125;g(t,i)\text&#123;d&#125;t</code> 显示为: $\displaystyle\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</p><h3 id="字母与杂项"><a href="#字母与杂项" class="headerlink" title="字母与杂项"></a>字母与杂项</h3><h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><table><thead><tr><th>显示</th><th>命令</th><th>显示</th><th>命令</th></tr></thead><tbody><tr><td>α</td><td>\alpha</td><td>β</td><td>\beta</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>γ</td><td>\gamma</td><td>δ</td><td>\delta</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>ϵ</td><td>\epsilon</td><td>ζ</td><td>\zeta</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>η</td><td>\eta</td><td>θ</td><td>\theta</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>ι</td><td>\iota</td><td>κ</td><td>\kappa</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>λ</td><td>\lambda</td><td>μ</td><td>\mu</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>ν</td><td>\nu</td><td>ξ</td><td>\xi</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>π</td><td>\pi</td><td>ρ</td><td>\rho</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>σ</td><td>\sigma</td><td>τ</td><td>\tau</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>υ</td><td>\upsilon</td><td>ϕ</td><td>\phi</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>χ</td><td>\chi</td><td>ψ</td><td>\psi</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>ω</td><td>\omega</td><td></td><td></td></tr></tbody></table><h4 id="修饰字母"><a href="#修饰字母" class="headerlink" title="修饰字母"></a>修饰字母</h4><ul><li><p>上下标:</p><ul><li>上标:<code>^</code>   </li><li>下标:<code>_</code></li><li>举例:<code>$a^2_n$</code> 显示为: $a^2_n$</li></ul></li><li><p>矢量</p><ul><li>单字母向量:<ul><li><code>$\vec a$</code> 显示为: $\vec a$</li><li><code>$\overrightarrow a$</code> 显示为: $\overrightarrow a$</li></ul></li><li>多字母向量: <ul><li>与单字母向量语法相同，只需要在两个或两个以上的字母用<code>&#123;...&#125;</code>括起来即可，如: <code>$\vec &#123;ab&#125;$</code>  ，显示为: $\vec {ab}$</li></ul></li></ul></li><li><p>特殊修饰</p><ul><li>字母上方 <code>^</code><ul><li>语句: <code>$\hat a$</code></li><li>显示: $\hat a$</li></ul></li><li>平均数<ul><li>语句: <code>$\overline a$</code></li><li>显示: $\overline a$</li></ul></li><li>下划线<ul><li>语句: <code>$\underline a$</code></li><li>显示: $\underline a$</li></ul></li></ul></li><li><p>字体</p><ul><li>TypeWriter <code>$\mathtt &#123;A&#125;$</code><ul><li>$\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</li></ul></li><li>Blackboard bold <code>$\mathbb &#123;A&#125;$</code><ul><li>$\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</li></ul></li><li>Sans Serif <code>$\mathsf &#123;A&#125;$</code><ul><li>$\mathsf {ABCDEFGHIJKLMNOPQRSTUVWXYZ}$</li></ul></li></ul></li><li><p>空格</p><ul><li>语法本身忽略空格，<code>$ab$</code> 和 <code>$a b$</code> 都显示为: $ab$</li><li>单空格: <ul><li>语句: <code>$a\ b$</code></li><li>显示: $a\ b$</li></ul></li><li>四格空格:<ul><li>语句: <code>$a\quad b$</code></li><li>显示: $a\quad b$</li></ul></li></ul></li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul><li>使用 {} 将同一级的括在一起，成组处理<ul><li>不使用: <code>$x_i^2$</code> , $x_i^2$</li><li>使用: <code>$x_&#123;i^2&#125;$</code> , $x_{i^2}$</li></ul></li></ul><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><ul><li><p>小括号，中括号普通书写即可，大括号使用转义字符<code>\</code>处理，如<code>$\&#123;...\&#125;$</code></p></li><li><p>尖括号: <code>$\langle ... \rangle$</code></p><ul><li>$\langle {ab} \rangle$</li></ul></li><li><p>绝对值: <code>$\vert ... \vert$</code></p><ul><li>$\vert {ab} \vert$</li></ul></li><li><p>双竖线: <code>$\Vert ... \Vert$</code></p><ul><li>$\Vert {ab} \Vert$</li></ul></li></ul><h3 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h3><blockquote><p>想要表达非的概念只需前加 \not，会添加删除斜线</p></blockquote><table><thead><tr><th>运算符</th><th>说明</th><th>实际应用</th><th>语句</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>$x+y$</td><td><code>$x+y$</code></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>-</td><td>减</td><td>$x-y$</td><td><code>$x-y$</code></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>\times</td><td>叉乘</td><td>$x\times y$</td><td><code>$x\times y$</code></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>\cdot</td><td>点乘</td><td>$x\cdot y$</td><td><code>$x\cdot y$</code></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>\div</td><td>除</td><td>$x\div y$</td><td><code>$x\div y$</code></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>=</td><td>等于</td><td>$x=y$</td><td><code>$x=y$</code></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>\approx</td><td>约等于</td><td>$x\approx y$</td><td><code>$x\approx y$</code></td></tr></tbody></table><h3 id="求和、极限、积分"><a href="#求和、极限、积分" class="headerlink" title="求和、极限、积分"></a>求和、极限、积分</h3><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><ul><li>求和符号 <code>$\sum$</code> 显示为 $\sum$</li></ul><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><ul><li>极限符号 <code>$\lim$</code> 显示为 $\lim$</li></ul><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><table><thead><tr><th>命令</th><th>显示</th></tr></thead><tbody><tr><td>\int</td><td>$\int$</td></tr><tr><td>—</td><td>—</td></tr><tr><td>\iint</td><td>$\iint$</td></tr><tr><td>—</td><td>—</td></tr><tr><td>\iiint</td><td>$\iiint$</td></tr><tr><td>—</td><td>—</td></tr><tr><td>\oint</td><td>$\oint$</td></tr></tbody></table><h3 id="分式、根式"><a href="#分式、根式" class="headerlink" title="分式、根式"></a>分式、根式</h3><h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h4><ul><li>语句: <code>$\frac&#123;...&#125;&#123;...&#125;$</code></li><li>显示: $\frac{x}{y}$</li></ul><h4 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h4><ul><li>语句: <code>$\sqrt[]&#123;&#125;$</code></li><li>显示: $\sqrt[x]{y}$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一份不严谨的FFmpeg入门教程</title>
      <link href="posts/81c18ef5.html"/>
      <url>posts/81c18ef5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>FFmpeg 是著名的音视频处理工具，常用的就是它的命令行(CLI)程序，这里不做安装说明</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>FFmpeg 的命令行参数非常多，可以分成五个部分: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg &#123;1&#125; &#123;2&#125; -i &#123;3&#125; &#123;4&#125; &#123;5&#125;</span></span><br></pre></td></tr></table></figure><p>上面命令中，五个部分的参数依次如下:</p><ol><li>全局参数, </li><li>输入文件参数, </li><li>输入文件, </li><li>输出文件参数, </li><li>输出文件</li></ol><p>参数太多的时候，为了便于查看，FFmpeg 命令可以写成多行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">[全局参数] \</span></span><br><span class="line"><span class="bash">[输入文件参数] \</span></span><br><span class="line"><span class="bash">-i [输入文件] \</span></span><br><span class="line"><span class="bash">[输出文件参数] \</span></span><br><span class="line"><span class="bash">[输出文件]</span></span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-y \ <span class="comment"># 全局参数</span></span></span><br><span class="line">-c:a libfdk_aac -c:v libx264 \ # 输入文件参数</span><br><span class="line">-i input.mp4 \ # 输入文件</span><br><span class="line">-c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数</span><br><span class="line">output.webm # 输出文件</span><br></pre></td></tr></table></figure><p>上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式，输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis</p><p>如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.avi output.mp4</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>FFmpeg 常用的命令行参数如下:</p><table><thead><tr><th>-c</th><th>指定编码器</th></tr></thead><tbody><tr><td>-c copy</td><td>直接复制，不经过重新编码（加快速度）</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-c:v</td><td>指定视频编码器</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-c:a</td><td>指定音频编码器</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-i</td><td>指定输入文件</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-an</td><td>去除音频流</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-vn</td><td>去除视频流</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-preset</td><td>指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow</td></tr><tr><td>—</td><td>—</td></tr><tr><td>-y</td><td>不经过确认，输出时直接覆盖同名文件</td></tr></tbody></table><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="查看文件信息"><a href="#查看文件信息" class="headerlink" title="查看文件信息"></a>查看文件信息</h3><p>查看视频文件的元信息，比如编码格式和比特率，可以只使用 -i 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4</span></span><br></pre></td></tr></table></figure><p>上面命令会输出很多冗余信息，加上 -hide_banner 参数，可以只显示元信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -hide_banner</span></span><br></pre></td></tr></table></figure><h3 id="转换编码格式"><a href="#转换编码格式" class="headerlink" title="转换编码格式"></a>转换编码格式</h3><p>转换编码格式 (transcoding) 指的是将音视频文件从一种编码转成另一种编码，比如将视频转成 H.264 编码，一般使用编码器 libx264，所以只需指定输出文件的视频编码器即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i [input.file] -c:v libx264 output.mp4</span></span><br></pre></td></tr></table></figure><p>转成 H.265 也一样: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i [input.file] -c:v libx265 output.mp4</span></span><br></pre></td></tr></table></figure><h3 id="转换容器格式"><a href="#转换容器格式" class="headerlink" title="转换容器格式"></a>转换容器格式</h3><p>转换容器格式 (transmuxing) 指的是，将视频文件从一种容器转到另一种容器，下面是 mp4 转到 webm 的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -i input.mp4 -c copy output.webm</span></span><br></pre></td></tr></table></figure><p>上面例子中，只是转一下容器，内部的编码格式不变，所以使用 -c copy 指定直接拷贝，不重新编码，速度会快很多</p><h3 id="调整码率"><a href="#调整码率" class="headerlink" title="调整码率"></a>调整码率</h3><p>调整码率 (transrating) 指的是，改变编码的比特率，一般用来将视频文件的体积变小，下面的例子指定码率最小为 964K，最大为 3856K，缓冲区大小为 2000K</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-i input.mp4 \</span></span><br><span class="line"><span class="bash">-minrate 964K -maxrate 3856K -bufsize 2000K \</span></span><br><span class="line"><span class="bash">output.mp4</span></span><br></pre></td></tr></table></figure><h3 id="调整分辨率"><a href="#调整分辨率" class="headerlink" title="调整分辨率"></a>调整分辨率</h3><p>下面是改变视频分辨率（transsizing）的例子，从 1080p 转为 480p</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-i input.mp4 \</span></span><br><span class="line"><span class="bash">-vf scale=480:-1 \</span></span><br><span class="line"><span class="bash">output.mp4</span></span><br></pre></td></tr></table></figure><h3 id="提取音频"><a href="#提取音频" class="headerlink" title="提取音频"></a>提取音频</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-i input.mp4 \</span></span><br><span class="line"><span class="bash">-vn -c:a copy \</span></span><br><span class="line"><span class="bash">output.aac</span></span><br></pre></td></tr></table></figure><p>上面例子中，-vn 表示去掉视频，-c:a copy 表示不改变音频编码，直接拷贝</p><h3 id="添加音轨"><a href="#添加音轨" class="headerlink" title="添加音轨"></a>添加音轨</h3><p>添加音轨（muxing）指的是，将外部音频加入视频，比如添加背景音乐或旁白</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-i input.mp3 -i input.mp4 \</span></span><br><span class="line"><span class="bash">output.mp4</span></span><br></pre></td></tr></table></figure><h3 id="输出帧"><a href="#输出帧" class="headerlink" title="输出帧"></a>输出帧</h3><p>下面的例子是从指定时间开始，连续对 1 秒钟的视频进行输出帧操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-y \</span></span><br><span class="line"><span class="bash">-i input.mp4 \</span></span><br><span class="line"><span class="bash">-ss 00:01:24 -t 00:00:01 \</span></span><br><span class="line"><span class="bash">output_%3d.jpg</span></span><br></pre></td></tr></table></figure><p>也可以只截取 1 帧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-ss 01:23:45 \</span></span><br><span class="line"><span class="bash">-i input \</span></span><br><span class="line"><span class="bash">-vframes 1 -q:v 2 \</span></span><br><span class="line"><span class="bash">output.jpg</span></span><br></pre></td></tr></table></figure><p>上面例子中，-vframes 1 指定只截取一帧，-q:v 2 表示输出的图片质量，一般是 1 到 5 之间 (1 为质量最高)</p><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p>裁剪 (cutting) 指的是，截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间 (start) 和持续时间 (duration) ，也可以指定结束时间 (end)</p><p>格式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</span></span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]</span></span><br></pre></td></tr></table></figure><h3 id="为音频添加封面"><a href="#为音频添加封面" class="headerlink" title="为音频添加封面"></a>为音频添加封面</h3><p>有些视频网站只允许上传视频文件，如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传</p><p>下面命令可以将音频文件，转为带封面的视频文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ffmpeg \</span></span><br><span class="line"><span class="bash">-loop 1 \</span></span><br><span class="line"><span class="bash">-i cover.jpg -i input.mp3 \</span></span><br><span class="line"><span class="bash">-c:v libx264 -c:a aac -b:a 192k -shortest \</span></span><br><span class="line"><span class="bash">output.mp4</span></span><br></pre></td></tr></table></figure><p>上面命令中，有两个输入文件，一个是封面图片 cover.jpg ，另一个是音频文件 input.mp3 ，-loop 1 参数表示图片无限循环，-shortest 参数表示音频文件结束，输出视频就结束</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在家测量光速</title>
      <link href="posts/ec079272.html"/>
      <url>posts/ec079272.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>几天前在网络上看到一个在家里精准测光速的视频，挺有趣的，分享给大家</p></blockquote><h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><table><thead><tr><th>材料</th><th>份</th></tr></thead><tbody><tr><td>长度大于10CM的巧克力</td><td>2</td></tr><tr><td>—</td><td>—</td></tr><tr><td>牙签</td><td>2</td></tr><tr><td>—</td><td>—</td></tr><tr><td>盘子</td><td>1</td></tr><tr><td>—</td><td>—</td></tr><tr><td>微波炉</td><td>1</td></tr><tr><td>—</td><td>—</td></tr><tr><td>直尺</td><td>1</td></tr></tbody></table><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>检查好巧克力🍫后，装盘放入微波炉中，大火加热25秒，注意不要让盘子转动</p></li><li><p>取出巧克力，观察融化明显的部分，用牙签标记出来，标记两处</p></li><li><p>用直尺测出两根牙签之间的距离，这里我们假设为6CM</p><p> <img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/27/Auc6OvxnRPH7BaK.png"></p></li></ol><p>可以看到融化的点在微波的波峰和波谷之间，所以波长等于两倍的牙签之间的距离</p><p>$$0.06\ \times\ 2\ =\ 0.12m$$</p><p>这其实是微波炉产生的驻波，两股方向相反的频率波长相同波相遇，停留不动，半个周期波峰波谷换位置，导致波峰波谷区域食物加热效率快与其他区域</p><ol start="4"><li>查看微波炉的频率，假设微波炉的频率为 2450MHZ </li></ol><p>根据波速的公式：波长 × 频率 = 波速</p><p>可以计算出波速等于:</p><p>$$0.12\ \times\ 2450000000\ =\ 294000000m/s$$</p><p>接近标准国际真空光速: 299792458m/s</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>微波炉标准微博波长为12.2厘米，一半是6.1厘米，所以理论建议实验用巧克力大于7CM就够用了</p><p>多实验几次，找更标准的尺子，这个值会更精准</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Cookie</title>
      <link href="posts/3442bd45.html"/>
      <url>posts/3442bd45.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者<a href="https://www.jianshu.com/u/02ecc98f9745">mcrwayfun</a>，转载自<a href="https://www.jianshu.com/p/6fc9cea6daa2">简书</a>，转载时有改动</p></blockquote><h2 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h2><p>HTTP 协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份，无状态是指 Web 浏览器与 Web 服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后 Web 服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息，也就是说，HTTP 请求只能由客户端发起，而服务器不能主动向客户端发送数据。</p><p>Cookie 实际上是一小段的文本信息（key-value 格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie。客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态</p><p>打个比方，我们去银行办理储蓄业务，第一次给你办了张银行卡，里面存放了身份证、密码、手机等个人信息。当你下次再来这个银行时，银行机器能识别你的卡，从而能够直接办理业务</p><h2 id="Cookie-机制"><a href="#Cookie-机制" class="headerlink" title="Cookie 机制"></a>Cookie 机制</h2><p>当用户第一次访问并登陆一个网站的时候，Cookie 的设置以及发送会经历以下 4 个步骤：</p><p>客户端发送一个请求到服务器,<br>服务器发送一个 HttpResponse 响应到客户端，其中包含 Set-Cookie 的头部,<br>客户端保存 Cookie ，之后向服务器发送请求时，HttpRequest 请求中会包含一个 Cookie 的头部,<br>服务器返回响应数据</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/27/P6NHwisBqueMYTn.png"></p><p>为了探究这个过程，写了代码进行测试，如下:</p><p>我在 doGet 方法中，new 了一个 Cookie 对象并将其加入到了 HttpResponse 对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;CHINQ&quot;</span>,System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置生命周期为MAX_VALUE</span></span><br><span class="line">    cookie.setMaxAge(Integer.MAX_VALUE);</span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Response Headers 中包含 Set-Cookie 头部，而 Request Headers 中包含了 Cookie 头部。name 和 value 正是上述设置的</p><h2 id="Cookie-属性项"><a href="#Cookie-属性项" class="headerlink" title="Cookie 属性项"></a>Cookie 属性项</h2><table><thead><tr><th>属性项</th><th>属性项介绍</th></tr></thead><tbody><tr><td>Name = Value</td><td>键值对，可以设置要保存的 Key / Value，注意这里的 Name 不能和其他属性项的名字一样</td></tr><tr><td>—</td><td>—</td></tr><tr><td>Expires</td><td>过期时间，在设置的某个时间点后该 Cookie 就会失效</td></tr><tr><td>—</td><td>—</td></tr><tr><td>Domain</td><td>生成该 Cookie 的域名，如 domain=”<a href="http://www.chinq.xyz&quot;/">www.chinq.xyz&quot;</a></td></tr><tr><td>—</td><td>—</td></tr><tr><td>Path</td><td>该 Cookie 是在当前的哪个路径下生成的，如 path=/post/</td></tr><tr><td>—</td><td>—</td></tr><tr><td>Secure</td><td>如果设置了这个属性，那么只会在 SSL 连接时才会回传该 Cookie</td></tr></tbody></table><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>该属性用来设置 Cookie 的有效期。Cookie 中的 maxAge 用来表示该属性，单位为秒。Cookie 中通过 getMaxAge () 和 setMaxAge (int maxAge) 来读写该属性。maxAge 有 3 种值，分别为正数，负数和 0</p><p>如果 maxAge 属性为正数，则表示该 Cookie 会在 maxAge 秒之后自动失效。浏览器会将 maxAge 为正数的 Cookie 持久化，即写到对应的 Cookie 文件中（每个浏览器存储的位置不一致）。无论客户关闭了浏览器还是电脑，只要还在 maxAge 秒之前，登录网站时该 Cookie 仍然有效。下面代码中的 Cookie 信息将永远有效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;CHINQ&quot;</span>,System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 设置生命周期为MAX_VALUE，永久有效</span></span><br><span class="line">cookie.setMaxAge(Integer.MAX_VALUE);</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>当 maxAge 属性为负数，则表示该 Cookie 只是一个临时 Cookie，不会被持久化，仅在本浏览器窗口或者本窗口打开的子窗口中有效，关闭浏览器后该 Cookie 立即失效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;CHINQ&quot;</span>,System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// MaxAge为负数，是一个临时Cookie，不会持久化</span></span><br><span class="line">cookie.setMaxAge(-<span class="number">1</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>当 maxAge 为 0 时，表示立即删除 Cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line">Cookie cookie = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Cookie</span></span><br><span class="line"><span class="keyword">for</span> (Cookie ck : cookies) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;CHINQ&quot;</span>.equals(ck.getName())) &#123;</span><br><span class="line">        cookie = ck;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != cookie) &#123;</span><br><span class="line">    <span class="comment">// Delete the cookie</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么 maxAge 设置为负值和 0 到底有什么区别呢？</strong></p><p>maxAge 设置为 0 表示立即删除该 Cookie，如果在 debug 的模式下，执行上述方法，可以看见 cookie 立即被删除了</p><p>maxAge 设置为负数，能看到 Expires 属性改变了，但 Cookie 仍然会存在一段时间直到关闭浏览器或者重新打开浏览器</p><h2 id="修改或者删除-Cookie"><a href="#修改或者删除-Cookie" class="headerlink" title="修改或者删除 Cookie"></a>修改或者删除 Cookie</h2><p>HttpServletResponse 提供的 Cookie 操作只有一个 addCookie (Cookie cookie)，所以想要修改 Cookie 只能使用一个同名的 Cookie 来覆盖原先的 Cookie。如果要删除某个 Cookie，则只需要新建一个同名的 Cookie，并将 maxAge 设置为 0，并覆盖原来的 Cookie 即可</p><p>新建的 Cookie，除了 value、maxAge 之外的属性，比如 name、path、domain 都必须与原来的一致才能达到修改或者删除的效果。否则，浏览器将视为两个不同的 Cookie 不予覆盖</p><p>值得注意的是，从客户端读取 Cookie 时，包括 maxAge 在内的其他属性都是不可读的，也不会被提交。浏览器提交 Cookie 时只会提交 name 和 value 属性，maxAge 属性只被浏览器用来判断 Cookie 是否过期，而不能用服务端来判断</p><p>我们无法在服务端通过 cookie.getMaxAge () 来判断该 cookie 是否过期，maxAge 只是一个只读属性，值永远为 - 1。当 cookie 过期时，浏览器在与后台交互时会自动筛选过期 cookie，过期了的 cookie 就不会被携带了</p><h2 id="Cookie-的域名"><a href="#Cookie-的域名" class="headerlink" title="Cookie 的域名"></a>Cookie 的域名</h2><p><strong>Cookie 是不可以跨域名的，隐私安全机制禁止网站非法获取其他网站的 Cookie</strong></p><p>正常情况下，同一个一级域名下的两个二级域名也不能交互使用 Cookie，比如 Cookie-1.chinq.xyz 和 Cookie-2.chinq.xyz，因为二者的域名不完全相同。如果想要 chinq.xyz 名下的二级域名都可以使用该 Cookie，需要设置 Cookie 的 domain 参数为.chinq.xyz，这样使用 Cookie-1.chinq.xyz 和 Cookie-2.chinq.xyz 就能访问同一个 Cookie</p><h2 id="Cookie-的路径"><a href="#Cookie-的路径" class="headerlink" title="Cookie 的路径"></a>Cookie 的路径</h2><p>path 属性决定允许访问 Cookie 的路径。比如，设置为 “/“ 表示允许所有路径都可以使用 Cookie</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝藏翻译软件DeepL!</title>
      <link href="posts/4193a622.html"/>
      <url>posts/4193a622.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.deepl.com/translator">DeepL</a>作为一款翻译软件，已经做出来很长时间了，相信很多小伙伴早已经听过这个翻译软件(Translator)的名号，网络上铺天盖地(<del>倒也不至于</del>)的文章，什么机器学习啊，爬虫啊，各种对它的介绍数不胜数，那么<del>我就来蹭一波热度</del>，来介绍一下这个DeepL Translator!</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/26/UxfumeO4Mqi9G13.png"></p><p>DeepL 翻译（DeepL Translator）是 2017 年 8 月由总部位于德国科隆的 DeepL GmbH（一家由 Linguee 支持的创业公司）推出的免费 神经机器翻译服务。评论家对于它的评价普遍正面，认为它的翻译比起 Google 翻译更为准确自然。(摘自维基百科)</p><p>DeepL的翻译服务搭建在Lineguee的数据库，并使用了卷积神经网络，开发者表示这是一种新型卷积神经网络，DeepL 的翻译是用一台浮点性能为 5 Petaflops 的超级电脑产生的，这台超级电脑位于冰岛，并依赖水力发电机来供电。一般来说卷积神经网络对于翻译长句子来说很有优势。</p><p>我们让DeepL Translator和Google Translator对比一下:</p><p>DeepL:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/26/vikFyM1pm5PwcsX.png"></p><p>Google Translator:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/26/paOARKXwjm4L1QB.png"></p><p>就可读性和口语化而言，我觉得DeepL的翻译更加本地化一点</p><hr><p>我们再来看一个例子：</p><p>这是我从网站上摘抄下来的一段话，我们看一下他的原翻译：</p><p>An individual human existence should be like a river—small at first, narrowly contained within its banks, and rushing passionately past boulders and over waterfalls. Gradually the river grows wider, the banks recede, the waters flow more quietly, and in the end, without any visible break, they become merged in the sea, and painlessly lose their individual being.</p><p>人的生命应当像河流，开始是涓涓细流，受两岸的限制而十分狭窄，尔后奔腾咆哮，翻过危岩，飞越瀑布，河面渐渐开阔，河岸也随之向两边隐去，最后水流平缓，森森无际，汇入大海之中，个人就这样毫无痛苦地消失了。</p><p>那这是DeepL的成绩：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/26/rDsXeLcMBiW5Ofz.png"></p><p>Google Translator:</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/26/lpDRcjbMrG9Nioz.png"></p><p>可以看到DeepL使用了很多<del>有深意</del>的词: 狭小，静谧</p><hr><p>上面我们看到的都是英文转中文，我们再尝试一下中文转英文，当然，普通的中文实在过于简单，我决定直接使用<strong>文言文</strong>来<del>虐</del>这<del>哥俩</del></p><hr><p>晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷。渔人甚异之，复前行，欲穷其林。</p><p>林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田、美池、桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。</p><p>见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。”</p><p>既出，得其船，便扶向路，处处志之。及郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。</p><p>南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终。后遂无问津者。</p><hr><p>这是魏晋时期陶渊明的词《桃花源记》，我用它作为测试样本（好像有点难为这<del>哥俩</del>了）</p><p>DeepL的成绩:</p><p>Jin Taiyuan, Wuling people fishing for business. When I was walking along the stream, I forgot the distance of the road. Suddenly, he came across a peach blossom forest, with hundreds of paces between the banks, no miscellaneous trees, fresh grass and colorful fallen Ying. The fisherman was very surprised, so he went ahead again and wanted to exhaust the forest.</p><p>When the forest was exhausted, he found a mountain with a small mouth, as if there was light. So he left his boat and entered through the mouth. At first it was very narrow, but only then did it allow people to pass. After a few dozen paces, it opened up. The land was flat and open, and the houses were in order, with good fields, beautiful ponds, mulberry and bamboo. Road traffic, dogs and chickens hear each other. Among them, men and women dressed as outsiders. The yellow-haired children, and happy to enjoy themselves.</p><p>When he saw the fisherman, he was surprised and asked where he had come from. He replied in kind. Then he wanted to return home and set up wine and killed a chicken for food. When the village heard of this man, they all came to ask about him. He told them that his ancestors had come to the village to escape the chaos of the Qin Dynasty, and that his wife had come to this desolate place. When he asked what time it was, he did not know there was a Han Dynasty, regardless of the Wei and Jin Dynasties. He told them what he had heard, and they all sighed. The rest of the group came back to his house and offered wine and food. They stopped for a few days and left. This person said, “It is not enough for outsiders to know.”</p><p>When he got out, he got his boat and helped him to the road. When he arrived at the county, he went to the governor and said so. The sheriff immediately sent someone to follow him, looking for what he wanted to do, but he was lost and never found the road again.</p><p>Liu Ziji of Nanyang, a noble scholar, heard about it and was glad to go. He was unsuccessful and died of illness. After that, there was no one who asked for help.</p><hr><p>Google Translator的成绩:</p><p>In the Taiyuan period of the Jin Dynasty, the people of Wuling made fishing. Travel by the river, forget the distance of the road. Suddenly there is a peach blossom forest, hundreds of steps across the bank, there are no miscellaneous trees, the grass is delicious, and the fallen flowers are colorful. The fisherman was very different, and went forward again, wanting to impoverish his forest.</p><p>If the forest is full of water, there will be a mountain with a small mouth, as if there is light. Convenience boat, enter from the mouth. Very narrow at the beginning, talented people. After dozens of steps, it suddenly became clear. The land is flat and the houses are just like farmland, beautiful pond, and mulberry bamboo. The traffic on the rice paddies, the chicken and the dog hear each other. Among them, the men and women are dressed like outsiders. The yellow hair hangs down, and he is happy.</p><p>Seeing the fisherman, I was shocked and asked everyone. Gu answered it. They had to return home and set up alcohol to kill chickens for food. The village heard that there was such a person, and came to inquire. Since Yun Xianshi escaped the chaos of the Qin Dynasty, and led his wife to come to this desperate situation, he never returned, so he was separated from outsiders. Asking what life is today, I don’t know whether there are Han, regardless of Wei Jin. This person was specific and heard one by one, and all sighed. The remaining people returned to their homes, all drinking and eating. Stop for a few days and resign. Someone said: “It’s not enough for outsiders.”</p><p>When you get out and get the boat, you will help you to the road and aim everywhere. And the county, the prefect, said so. The prefect sent people to follow him, looking for what he wanted, and then lost his way and no longer found the way.</p><p>Nanyang Liu Ziji, a noble scholar, heard about it, and walked happily. Unsuccessful, find the disease eventually. Then there were no interested parties.</p><p>我将它们的翻译结果重新翻译回中文，看看是否可读：</p><p>DeepL:</p><p>晋太原，武陵人钓商。沿溪而行，忘了路途的远近。忽见一桃花林，两岸相隔数百步，无杂树，草木鲜美，落英缤纷。渔夫大为惊奇，遂又前行，欲尽林中。</p><p>穷尽林中，忽见一山，口小，如有光。于是他离开船，从口中进入。初时十分狭窄，后来才让人通过。过了几十步，便豁然开朗。地势平坦开阔，房屋井然有序，良田美池，桑竹茂盛。道路交通，鸡犬相闻。其中，有男有女，装扮成外地人。黄发童子，乐此不疲。</p><p>渔夫见之，惊诧不已，问其从何而来。渔翁答以善意。遂欲归家，设酒杀鸡为食。村里人听说这个人，都来问他的情况。他告诉他们，他的祖先为了躲避秦朝的乱世，来到这个荒凉的地方，他的妻子也来到了这个村子。问他现在是什么时候，他不知道有汉朝，不管魏晋。他把所听到的情况告诉了他们，他们都叹了口气。其余的人又来到他家，献上酒菜。停了几日，便走了。此人说：”外人知道还不够。”</p><p>出门后，他取了船，扶他上路。到了县城，他到知县那里去说。县令立即派人跟踪他，寻找他要做的事，但他迷路了，再也找不到路了。</p><p>南阳的刘子骥是个贵族书生，听说了这件事，欣然前往。不料未能成功，病死。此后，无人问津。</p><p>Google Translator:</p><p>在金太原时期，武陵人捕鱼。在河边旅行，忘了路的距离。忽然有一片桃花林，横跨河岸几百步，没有杂树，草丛鲜美，落花缤纷。渔夫与众不同，他再次前进，想要使他的森林变得贫穷。</p><p>如果森林里到处都是水，那么山上就会有一小口，仿佛有光。方便船，从口进入。刚开始时人才很狭窄。经过几十个步骤，它突然变得清晰起来。土地平坦，房屋就像农田，美丽的池塘和桑bamboo。稻田上的交通，鸡和狗互相听见。其中，男女打扮得像局外人。黄头发垂下来，他很高兴。</p><p>看到渔夫，我很震惊，问了所有人。顾回答了。他们不得不返回家乡并建立酒精来杀死鸡肉作为食物。村里听说有这样一个人，就来询问。由于Yun贤石摆脱了秦朝的混乱，并带领他的妻子陷入了这种绝望的境地，他再也没有回来，因此与外界隔离。问今天的生活，我不知道是否有汉族，与魏晋无关。这个人很具体，一个人一个人听到，所有人都叹了口气。其余的人都回到家，喝酒和吃饭。停几天，然后辞职。有人说：“对于局外人来说这还不够。”</p><p>当您下船并乘船时，您将帮助您上路并瞄准任何地方。县长也这么说。县长派人跟随他，寻找他想要的东西，然后迷路了，不再找到路。</p><p>贵族学者南洋刘子集闻所未闻，开心地走着。不成功，最终找到疾病。那时没有感兴趣的团体。</p><blockquote><p>大致看去，想都不用想肯定是DeepL完胜，因为明明是英译中，Google Translator翻译的结果还存在英文字符，实属不应该</p></blockquote><p>我们再看一下翻译的结果，DeepL翻译的貌似还很有文言文那味儿，可读性很高；而Google Translator…<del>谷歌生草机(不是)</del></p><hr><p>总的来说，DeepL完全可以胜任日常的翻译工作，虽然免费版单词只能翻译5000个字符，不过瑕不掩玉，它配得上顶尖机器翻译的名号</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勾股定理的验证</title>
      <link href="posts/9432a139.html"/>
      <url>posts/9432a139.html</url>
      
        <content type="html"><![CDATA[<p>今天我们来验证一下勾股定理(<del>因为实在是没有东西写了</del>)吧: </p><p>勾股定理(Pythagorean Theorem): </p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/25/TpOUMjy7PaLVGgZ.png"></p><p>如上图所示，，在直角三角形ABC当中，</p><p>$$ a^2\ +\ b^2\ =\ c^2 $$</p><p>也就是说，出除了斜边之外的两条边的长度的平方<code>^2</code>相加 = 斜边长度的平方</p><hr><p>不管你是否记得勾股定理都不要紧，要紧的是，对这个定理进行验证之后，你感受到了什么，又学到了什么</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/25/lKjiSrQLxCNwZoT.png"></p><p>如上图所示，将四个直角三角形拼接在一起，形成一个边长为 $(a\ +\ b)$ 的大正方形，当中还有一个边长为 $c$ 的小正方形，让我们来看一下他们的面积：</p><p>大正方形的面积 = 小正方形的面积 + 直角三角形的面积 × 4 …❤</p><p>我们可以得出如上这样的一个答案</p><p>接下来，让我们用英文字符来表示面积：</p><ul><li><p>大正方形的面积为：$(a\ +\ b)^2$</p></li><li><p>小正方形的面积为：$c^2$</p></li><li><p>直角三角形的面积为：$a\ \times\ b\ \div\ 2\ =\ \frac{ab}{2}$</p></li></ul><p>我们将这些面积带入到❤号方程式当中去，得出：</p><p>$$(a\ +\ b)^2\ =\ c^2\ +\ \frac{ab}{2}\ \times\ 4\ =\ c^2\ +\ 2ab$$</p><p>然后我们再对等号左边的 $(a\ +\ b)^2$ 进行展开：</p><p>$$(a\ +\ b)^2\ =\ a^2\ +\ 2ab\ +\ b^2$$</p><blockquote><p>如果你没有掌握乘法公式的话，$(a\ +\ b)\ (a\ +\ b)\ =a^2\ +\ ab\ +\ ab\ +\ b^2$<br>那么你可以像这样实际计算一下，从而得到确认</p></blockquote><p>接下来将展开之后的 $(a\ +\ b)^2$ 带入到❤号方程式当中去：</p><p>$$a^2\ +\ 2ab\ +\ b^2\ =\ c^2\ +\ 2ab$$</p><p>最终得出：</p><p>$$ a^2\ +\ b^2\ =\ c^2 $$</p><p>至此，对勾股定理的验证就完成了，顺便还复习了一下乘法公式，一举两得，<del>岂不美哉(应该是水了一篇文章很爽)</del></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Hexo-Deploy的问题</title>
      <link href="posts/31ced5fe.html"/>
      <url>posts/31ced5fe.html</url>
      
        <content type="html"><![CDATA[<p>在上次的<a href="https://www.chinq.xyz/2021/01/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84Deploy%E5%8A%9F%E8%83%BD/">《如何使用Hexo的Deploy功能》</a>这篇文章里，我详细介绍了hexo的deploy功能如何使用</p><p>但在那篇文章的评论区，我也说明了一个问题，就是每次deploy时，自定义域名都会变回原来的<code>username.github.io/repository</code>这样的格式，这样就很烦躁，每次deploy都要重新修改一次自定义域名，但是不用deploy就得手动<code>commit/push</code>，就很麻烦…</p><p>今天在无意间我和 <strong>sama(O7I2)</strong> 的一次通话中了解到了解决方法，分享给大家</p><hr><p>我以前在用Gridea写博客的时候，第一步肯定是配置，配置的时候会让我们选择输入<code>CNAME</code>，如果你配置了，每次部署时你会在Github仓库里看到<code>CNAME</code>这个文件，里面的内容就是你在<code>CNAME</code>那个输入框里写的</p><p>如果没有这个<code>CNAME</code>文件，Gridea每次部署也会变为<code>username.github.io/repository</code>，好了，现在知道问题出自哪了，每次部署(deploy)hexo的时候，hexo没有把<code>CNAME</code>文件连同你的博客文件一同部署上去，所以我们只需要让hexo每次部署时连同<code>CNAME</code>文件也部署上去就好了</p><p>可问题来了，如何让hexo部署<code>CNAME</code>文件呢，其实仔细观察一下，不难发现，我们的主题引用的<code>CSS, JS</code>等都会存放在<code>themes/theme_name/source/</code>下，而主题的完美运行也是需要这些文件的，所以hexo会在部署时会把这个/source文件夹的内容部署上去，所以我们只需要在这个文件夹下创建一个<code>CNAME</code>文件就好了</p><blockquote><p>注: <code>CNAME</code>文件不需要任何的后缀，内容为你的自定义域名，不要加 http/https!</p></blockquote><p>加入<code>CNAME</code>文件后使用<code>hexo clean</code>或<code>hexo cl</code>来清理你的/public文件夹，然后用<code>hexo g</code>重新生成，再使用<code>hexo deploy</code>或<code>hexo d</code>部署</p><p>部署好后尝试访问你的网站，就可以正常访问了，以后也不需要手动修改自定义域名了!</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Pjax实现网站无刷新加载？</title>
      <link href="posts/ffa92af.html"/>
      <url>posts/ffa92af.html</url>
      
        <content type="html"><![CDATA[<h2 id="pjax是什么"><a href="#pjax是什么" class="headerlink" title="pjax是什么?"></a>pjax是什么?</h2><p>pjax 是一个 jQuery 插件，它通过 ajax 和 pushState 技术提供了极速的（无刷新 ajax 加载）浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。</p><p>pjax 的工作原理是通过 ajax 从服务器端获取 HTML，在页面中用获取到的 HTML 替换指定容器元素中的内容。然后使用 pushState 技术更新浏览器地址栏中的当前地址。</p><p>以下两点原因决定了 pjax 会有更快的浏览体验：</p><ol><li><p>不存在页面资源（JS/CSS）的重复加载和应用；</p></li><li><p>如果服务器端配置了 pjax，它可以只渲染页面局部内容，从而避免服务器渲染完整布局的额外开销</p></li></ol><h3 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h3><p>jQuery-pjax 的维护方向：可能会继续修复重要的 bug，但其功能不会再发生变化，即不会再实现新功能，也不会再扩展现有功能</p><h2 id="如何使用pjax"><a href="#如何使用pjax" class="headerlink" title="如何使用pjax?"></a>如何使用pjax?</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端设置分两步：</p><ol><li><p>下载插件，包括 jQuery1.8+，或者 npm 安装，这部分参考文档，不赘述</p></li><li><p>初始化 pjax 插件，并有条件的拦截</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.fn.pjax</span><br></pre></td></tr></table></figure><p>以下代码表示：当 selector 被点击时，执行 ajax 请求，并将返回的 HTML 字符串填充在 container 标记的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).pjax(selector, [container], options)</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>selector：string 类型，用于 click 事件委托 的选择器</li><li>container：string 类型，用于标识唯一 pjax 容器的选择器</li><li>options object 类型，包含下列选项</li></ul><p>pjax 配置选项</p><table><thead><tr><th>选项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>timeout</td><td>650</td><td>ajax 超时时间（毫秒），超时后强制刷新整个页面</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>push</td><td>true</td><td>使用pushState在浏览器中添加历史记录</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>replace</td><td>false</td><td>替换 URL 地址但不添加浏览器历史记录</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>maxCacheLength</td><td>20</td><td>容器元素缓存内容的最大值（次）</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>version</td><td></td><td>string 或 function，返回当前 pjax 版本</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>scrollTo</td><td></td><td>浏览器滚动条的垂直滚动位置。设为 false 时禁止滚动</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>type</td><td>“GET”</td><td>参考<code>$.ajax</code></td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>dataType</td><td>“HTML”</td><td>参考<code>$.ajax</code></td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>container</td><td></td><td>被替换内容元素的 CSS 选择器</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>url</td><td>link.href</td><td>string 或 function，返回 ajax 请求响应的 URL</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>target</td><td>link</td><td>pjax事件中 relatedTarget 属性的最终值</td></tr><tr><td>—</td><td>—</td><td>—</td></tr><tr><td>fragment</td><td></td><td>CSS 选择器，提取 ajax 响应内容中指定的内容片段</td></tr></tbody></table><p>可以在全局使用 <code>$.pjax.defaults</code> 对象改变默认配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.pjax.defaults.timeout = <span class="number">1200</span></span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端也比较简单，监听 HTTP 的 header 中有 X-pjax 的 ajax 请求，如果有则返回 HTML 片段，而不是整个 HTML</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><h3 id="fn-pjax"><a href="#fn-pjax" class="headerlink" title="$.fn.pjax"></a>$.fn.pjax</h3><p>最简单常见的 pjax 使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).pjax(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;#pjax-container&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过这种方式可以让页面中所有的链接都实现 pjax 加载，并指定 #pjax-container 作为容器元素</p><hr><h3 id="pjax-click"><a href="#pjax-click" class="headerlink" title="$.pjax.click"></a>$.pjax.click</h3><p>这是一个 <code>$.fn.pjax</code> 内部使用的底层方法，通过此方法可以在 pjax 事件之上做更多的事情。本示例使用当前的 click 上下文来设置一个祖先元素作为容器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($.support.pjax) &#123;</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;a[data-pjax]&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> container = $(<span class="built_in">this</span>).closest(<span class="string">&#x27;[data-pjax-container]&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> containerSelector = <span class="string">&#x27;#&#x27;</span> + container.id</span><br><span class="line">        $.pjax.click(event, &#123;<span class="attr">container</span>: containerSelector&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pjax-submit"><a href="#pjax-submit" class="headerlink" title="$.pjax.submit"></a>$.pjax.submit</h3><p>通过 pjax 提交表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;submit&#x27;</span>, <span class="string">&#x27;form[data-pjax]&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    $.pjax.submit(event, <span class="string">&#x27;#pjax-container&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="pjax-reload"><a href="#pjax-reload" class="headerlink" title="$.pjax.reload"></a>$.pjax.reload</h3><p>使用 pjax 机制发起一个当前 URL 的请求到服务器，并且通过响应的内容替换容器元素中的内容，同时不添加浏览器历史记录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.pjax.reload(<span class="string">&#x27;#pjax-container&#x27;</span>, options)</span><br></pre></td></tr></table></figure><h3 id="pjax"><a href="#pjax" class="headerlink" title="$.pjax"></a>$.pjax</h3><p>手动调用 pjax。主要用于非 click 事件发起 pjax 请求的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyFilters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = urlForFilters()</span><br><span class="line">    $.pjax(&#123;<span class="attr">url</span>: url, <span class="attr">container</span>: <span class="string">&#x27;#pjax-container&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>除了 pjax:click 和 pjax:clicked，其他所有 pjax 事件都是在 pjax 容器元素上触发的。</p><table><thead><tr><th>事件</th><th>取消</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>pjax 链接事件的生命周期</td><td></td><td></td><td></td></tr><tr><td>—</td><td></td><td></td><td></td></tr><tr><td>pjax:click</td><td>✔︎</td><td>options</td><td>链接被激活的时候触发；取消的时候阻止 pjax</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:beforeSend</td><td>✔︎</td><td>xhr, options</td><td>可以设置 XHR 头</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:start</td><td></td><td>xhr, options</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:send</td><td></td><td>xhr, options</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:clicked</td><td></td><td>options</td><td>pjax 通过链接点击已经开始之后触发</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:beforeReplace</td><td></td><td>contents, options</td><td>从服务器端加载的 HTML 内容完成之后，替换当前内容之前</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:success</td><td></td><td>data, status, xhr, options</td><td>从服务器端加载的 HTML 内容替换当前内容之后</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:timeout</td><td>✔︎</td><td>xhr, options</td><td>在 options.timeout 之后触发；除非被取消，否则会强制刷新页面</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:error</td><td>✔︎</td><td>xhr, textStatus, error, options</td><td>ajax 请求出错；除非被取消，否则会强制刷新页面</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>pjax:complete</td><td></td><td>xhr, options</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>浏览器前进后退事件的生命周期</td><td></td><td></td><td></td></tr><tr><td>—</td><td></td><td></td><td></td></tr><tr><td>pjax:popstate</td><td></td><td>direction事件的属性: “back”/“forward”</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:start</td><td>null, options</td><td>内容替换之前</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:beforeReplace</td><td>contents, options</td><td>在用缓存中的内容替换 HTML 之前</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:end</td><td>null, options</td><td>替换内容之后</td><td></td></tr><tr><td>—</td><td>—</td><td>—</td><td></td></tr><tr><td>pjax:callback</td><td>null, options</td><td>页面脚本加载完成后（Admui 项目）</td><td></td></tr></tbody></table><p>如果您使用了加载指示（如 loading 图标或 “加载中” 的文字），pjax:send 和 pjax:complete 这两个事件会比较有用。它们只有在 XHR 请求（而不是从缓存中加载内容）时才会被触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;pjax:send&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#loading&#x27;</span>).show()</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;pjax:complete&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#loading&#x27;</span>).hide()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以下是禁用 pjax:timeout 事件的示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">&#x27;pjax:timeout&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent default timeout redirection behavior</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在地址栏输入URL后，浏览器发生了什么？</title>
      <link href="posts/26c566f.html"/>
      <url>posts/26c566f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作者<a href="https://www.jianshu.com/u/e8e57b673e6b">Dreammin_chen</a>，转载自<a href="https://www.jianshu.com/p/c1dfc6caa520">简书</a>，转载时有改动</p></blockquote><p><strong>在浏览器中输入URL后，浏览器都发生了哪些事情呢？</strong>跟我一起来看看吧：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/20/hcaCu1tyHUZgF6v.png"></p><p>我将该过程分为了以下六步：</p><h3 id="1-DNS-域名解析"><a href="#1-DNS-域名解析" class="headerlink" title="1. DNS 域名解析"></a>1. DNS 域名解析</h3><ul><li>在浏览器 DNS 缓存中搜索</li><li>在操作系统 DNS 缓存中搜索</li><li>读取系统 hosts 文件，查找其中是否有对应的 IP</li><li>向本地配置的首选 DNS 服务器发起域名解析请求</li></ul><h3 id="2-建立-TCP-连接"><a href="#2-建立-TCP-连接" class="headerlink" title="2. 建立 TCP 连接"></a>2. 建立 TCP 连接</h3><p>为了准确地传输数据，TCP 协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有 SYN/ACK (acknowledegment) 标志的数据包以示传达确认信息。最后发送方再回传一个带 ACK 标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP 会再次发送相同的数据包。<br> TCP 是一个端到端的可靠的面向连接的协议，所以 HTTP 基于传输层 TCP 协议不用担心数据的传输的各种问题</p><h3 id="3-发起-HTTP-请求"><a href="#3-发起-HTTP-请求" class="headerlink" title="3. 发起 HTTP 请求"></a>3. 发起 HTTP 请求</h3><p>请求方法：</p><ul><li> GET: 获取资源</li><li> POST: 传输实体主体</li><li> HEAD: 获取报文首部</li><li> PUT: 传输文件</li><li> DELETE: 删除文件</li><li> OPTIONS: 询问支持的方法</li><li> TRACE: 追踪路径</li></ul><p>请求报文：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/20/cq2hpOrHkXYjNJS.png"></p><h3 id="4-接受响应结果"><a href="#4-接受响应结果" class="headerlink" title="4. 接受响应结果"></a>4. 接受响应结果</h3><p>状态码：</p><ul><li> 1**： 信息性状态码</li><li>2**： 成功状态码<br> 200：OK 请求正常处理<br> 204：No Content 请求处理成功，但没有资源可返回<br> 206：Partial Content 对资源的某一部分的请求</li><li>3**： 重定向状态码<br> 301：Moved Permanently 永久重定向<br> 302：Found 临时性重定向<br> 304：Not Modified 缓存中读取</li><li>4**： 客户端错误状态码<br> 400：Bad Request 请求报文中存在语法错误<br> 401：Unauthorized 需要有通过 Http 认证的认证信息<br> 403：Forbidden 访问被拒绝<br> 404：Not Found 无法找到请求资源</li><li>5**： 服务器错误状态码<br> 500：Internal Server Error 服务器端在执行时发生错误<br> 503：Service Unavailable 服务器处于超负载或者正在进行停机维护</li></ul><p>响应报文：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/20/fIj95mlRTNPHCAG.png"></p><h3 id="5-浏览器解析-HTML"><a href="#5-浏览器解析-HTML" class="headerlink" title="5. 浏览器解析 HTML"></a>5. 浏览器解析 HTML</h3><p>浏览器按顺序解析 HTML 文件，构建 DOM 树，在解析到外部的 CSS 和 JS 文件时，向服务器发起请求下载资源，若是下载 CSS 文件，则解析器会在下载的同时继续解析后面的 HTML 来构建 DOM 树，则在下载 JS 文件和执行它时，解析器会停止对 HTML 的解析。这便出现了 JS 阻塞问题</p><p><strong>预加载器</strong>：<br>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的 HTML，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索 HTML 标签中的 URL，无法检测到使用脚本添加的 URL，这些资源要等脚本代码执行时才会获取。<br> 注：预解析并不改变 DOM 树，它将这个工作留给主解析过程</p><p>浏览器解析 CSS，形成 CSSOM 树，当 DOM 树构建完成后，浏览器引擎通过 DOM 树和 CSSOM 树构造出渲染树。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head 元素和 display 值为 none 的元素）</p><blockquote><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p></blockquote><h3 id="6-浏览器布局渲染"><a href="#6-浏览器布局渲染" class="headerlink" title="6. 浏览器布局渲染"></a>6. 浏览器布局渲染</h3><ul><li>布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li><li>绘制：将计算好的每个像素点信息绘制在屏幕上</li></ul><p>在页面显示的过程中会多次进行 Reflow 和 Repaint 操作，而 Reflow 的成本比 Repaint 的成本高得多的多。因为 Repaint 只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的 display 属性由 block 改为 none 则需要 Reflow</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/20/xeAwPEHzM8pF4tc.png"></p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个Terraria的奇妙好东西</title>
      <link href="posts/f128fb1e.html"/>
      <url>posts/f128fb1e.html</url>
      
        <content type="html"><![CDATA[<p>HI!</p><p>这里是CHINQ啊，Terraria有个奇妙的东西</p><p>就是在旅途模式下的官方作弊的东西（鬼知道Terraria官方为什么要开发这个），反正特别强就是了</p><p>可是旅途模式只能在旅途地图使用，那么有没有什么办法把在旅途模式的作弊插件放到普通地图（除旅途外的所有类型地图）使用呢？</p><p>官方肯定是不允许你这样做的，但是，有一种东西，它叫：</p><p><strong>人物存档修改器</strong>…</p><hr><p>在旅途模式里，有很多作弊用的东西，就拿这个<code>God Mode</code>举例子，这玩意就相当于锁血，锁蓝（就是不掉血，不消耗魔法啦），那么这个东西要怎么带到别的地图使用呢？接着往下看吧！</p><p><a href="https://yal.cc/r/terrasavr/"><strong>Terrasavr</strong></a>————YellowAfterLife大佬开发的一个人物存档修改器，有网页端和客户端（<strong>不是广告</strong>）</p><blockquote><p>注: 因为是外国服务器，可能需要梯子，梯子请自备</p></blockquote><p>网站上有部分汉化的简体中文，字体也使用了Terraria的风格（只有英文才是），主界面是这样的：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/19/RyCJeAWa82HSYIw.png" alt="image.png"></p><p>选择加载存档：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/19/d73BAFfYT9XK52z.png" alt="image.png"></p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/19/v28W5cr3gpV1Bwi.png" alt="image.png"></p><blockquote><p>不要在意我这个人物存档，乱改的，这里我只说说怎么把旅途模式的<code>God Mode</code>（其他同理）允许在其他存档使用</p></blockquote><hr><p>首先先在Terraria创建一个旅途人物，随便进入一个地图，把<code>God Mode</code>打开，保存并退出，接着你就可以找到你的人物存档是一个叫做：</p><p><code>name.plr</code>的文件（不知道存档在哪里的见上面的图）</p><p>我们将这个文件载入到Terrasavr中，并将其模式修改为除旅途模式的任意一个其他模式：</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/19/Bjn2mzG6Mrp8hEs.png" alt="image.png"></p><p>然后保存存档，将该存档覆盖你的老存档，现在即可进入其他世界体验旅途的快乐（不是）了！</p><p>因为旅途模式的<code>God Mode</code>并不依赖旅途使用，所以只修改模式并不会影响它的使用</p><p>总结：<br>创建旅途存档，把想要的作弊模式打开，<br>导入存档至Terrasavr，把模式修改为旅途之外，<br>保存存档，覆盖之前的老存档，<br>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> 水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是RSA?</title>
      <link href="posts/7a115577.html"/>
      <url>posts/7a115577.html</url>
      
        <content type="html"><![CDATA[<div class="note success flat"><p>强烈建议放大观看，Mathjax渲染的公式有点小，见谅！</p></div><p>一直到上个世纪70年代，人们都还在使用对称加密算法，也就是说信息的收发方会通过事先商定好的密钥对数据进行加密和解密 </p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/17/QlDfwCdoiGFamLr.png" alt="image.png"></p><p>然而，这种加密方式有诸多缺陷，随着网络规模的不断增大，每多一个用户就需要保存额外的密钥，密钥的管理也将逐渐成为所有人的负担 </p><p>更加致命的是，密钥必须通过见面协商，而没有办法通过网络进行交换，因为密钥的传输过程需要进行加密，而没有密钥，则不能进行加密 </p><p>那有没有一种可能性，我们用不同的密钥对数据进行加密和解密</p><p><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/17/AzEm1Xr4OT5ayLe.png" alt="image.png"></p><p>对数据加密的密钥，即公钥，是公开的，而对数据解密的密钥却仅为接收者持有？</p><p><strong>这个问题，在1978年得到了解答</strong></p><hr><p>因为公钥是对所有人公开的信息，我们需要保证数据被公钥加密后，不能轻易地反推出来，那么什么算法单项计算容易，反推却极难呢？</p><p><strong>模运算</strong>(Modular Artithmetic)，又称求余计算，像计算机中的假随机生成的随机数，散列算法都是他的典型应用 </p><p>我来举个例子：</p><p>$$3^3\ mod\ 7$$</p><p>很简单，答案是6</p><p>$$3^3\ mod\ 7\ =\ 6$$</p><p>但已知答案是<code>6</code>，要求<code>x</code>，就很难了</p><p>$$3^x\ mod\ 7\ =\ 6$$</p><p>因为模运算不可逆的原因，我们只能带进一个数值一个一个去试，那如果这里出现了超级大的数，想逆推这个等式几乎不可能</p><p>$$3^x\ mod\ 9871649871751784351784561874657819346\ =\ 6$$</p><p>而公钥加密正是利用了模运算的这个特性，假设我们将原始数据表示成一个数<code>m</code>(message)，我们对它求<code>e</code>次幂</p><p>$$m^e$$</p><p><strong>e(encrypt)可以看成我们加密使用的密钥</strong></p><p>然后我们将结果除以N并取余数，最后得到密文<code>c</code>(cipher)</p><p>加密:</p><p>$$m^e\ mod\ N\ =\ c$$</p><p>解密:</p><p>$$c^d\ mod\ N\ =\ m$$</p><p><strong>d(decrypt)可以看成我们解密使用的密钥</strong></p><p>综合一下这两个式子，合并成下面这样:</p><p>$$m^{ed}\ mod\ N\ =\ m$$</p><p>可以发现，如何选取这里的<code>e, d</code>变成了公钥加密中最关键的问题…</p><hr><p>1763年，欧拉有了一个重要发现 ———— 欧拉定理(Euler’s Theorem)</p><p>$$m^{\phi(n)}\ =\ 1\ (mod\ n)$$</p><p>对于一个任何与<code>n</code>互质的正整数<code>m</code>，提取他的<code>φ(n)</code>次方，并处以<code>n</code>去余数，结果永远等于<code>1</code></p><p>那么，<code>φ(n)</code>又是什么呢？</p><p>它代表在小于或等于<code>n</code>的正整数中，有多少个与<code>n</code><strong>互质</strong>的数</p><p>我举个例子，这里我们取<code>n = 6</code></p><p>我们会发现在小于等于<code>6</code>的正整数中，只有<code>1</code>和<code>5</code>与<code>6</code>互质，所以<code>φ(6) = 2</code></p><p>了解了<code>φ</code>后，我们回到欧拉定理，尝试着对公式进行一些简单的变换</p><p>$$m^{\phi(n)}\ =\ 1\ (mod\ n)$$</p><p>在等式的两端取<code>k</code>次幂</p><p>$$m^{k\phi(n)}\ =\ 1\ (mod\ n)$$</p><p><strong><code>k</code>在这里代表任意的正整数</strong></p><p>接着我们在两端同时乘<code>m</code></p><p>$$m^{k\phi(n)+1}\ =\ m\ (mod\ n)$$</p><p>最后我们将模运算写在等式的左边</p><p>$$m^{k\phi(n)+1}\ mod\ n\ =\ m$$</p><p>将这个公式和上面的加密解密公式对应起来，我们会发现这里公式的指数部分相同，则我们可以将<code>d</code>与<code>e</code>的关系表示成这种形式:</p><p>$$d\ =\ \frac{k\phi(n)+1}{e}$$</p><p>我们可以通过选取这里的<code>k, n, e</code>来计算出解密的密钥<code>d</code></p><p>而这个公式中的<code>φ(n)</code>，不是那么的简单，但它还恰巧是公钥加密中最关键的部分</p><p>实际上，要计算出<code>φ(n)</code>的唯一办法就是对这个<code>n</code>做质因数分解，然而大数的质因数分解本身是非常困难的事情，所以说当<code>n</code>特别大时，对<code>φ(n)</code>的求解可以看作是计算上不可行的</p><p>但是，如果<code>n</code>本身就是一个质数，那么情况就会有所改变</p><p>比如质数<code>7</code>，小于等于<code>7</code>的并于<code>7</code>互质的数有<code>1-6</code>，所以<code>φ(7)=6</code></p><p>所以，只要<code>n</code>是质数，则<code>φ(n) = n - 1</code></p><p>φ函数还有一个重要的特性，就是:</p><p>$$\phi(p\ \times\ q)\ =\ \phi(p)\ \times\ \phi(q)$$</p><p>例如，我们可以选取两个质数，<code>17</code>和<code>23</code>，则:</p><p>$$\phi(17\ \times\ 23)\ =\ \phi(17)\ \times\ \phi(23)\ =\ 16\ \times\ 22\ =\ 352$$</p><p>因此我们可以轻易求得$\phi(17 \times 23) = \phi(391) = 352$</p><p>带入我们之前的公式:$d\ =\ \frac{k\phi(n)+1}{e}$</p><p>然后选取一个较小的数<code>e = 3</code>，这里我们需要保证它与<code>φ(n)</code>互质</p><p>于是在<code>k = 5</code>的情况下：</p><p>$$d\ =\ \frac{k\phi(n)+1}{e}\ =\ \frac{5\ \times\ 352\ +\ 1}{3}\ =\ 587$$</p><p>求出了私钥<code>d</code>，我们不需要<code>p</code>和<code>q</code>了，算法会将<code>e</code>和<code>n</code>公布，做加密的公钥<code>(public key)</code>，而<code>d</code>做保存下来作为解密时用的私钥<code>(private key)</code></p><p>其他人因为不知道<code>p, q</code>这两个关键的质因数，也没有办法计算出<code>φ(n)</code>，也没法破解这里的私钥<code>d</code></p><p>公钥加密正是利用了这个信息不对等，让加密者能够快速构造出一个<code>φ(n)</code>，而其他人却无法在有限的时间内求解它</p><p>我们可以用求得的<code>e, d, n</code>来模拟一段信息加密解密过程：</p><p>$$e\ =\ 3\ |\ d\ =\ 587\ |\ n\ =\ 391$$</p><p>我们要加密的字符是<code>a</code>，<code>a</code>的ascii编码是<code>97</code>，所以<code>m = 97</code></p><p>于是$97^3\ mod\ 391\ =\ 79$，<code>79</code>是我们加密后的密文，即<code>c</code></p><p>为了解密，我们计算$79^{587}\ mod\ 391\ =\ 97$，计算出原始数据为<code>97</code></p><p>以上讲到的，便是公钥加密算法的全部工作原理，这个算法在首次被发现后就被政府作为机密尘封起来，后来又在1977年又被三个麻省理工的数学家独立发掘，即为当下众所周知的著名的RSA算法，RSA这个名字也是由三位数学家的姓来命名的：</p><p>Ron <strong>R</strong>ivest | Adi <strong>S</strong>hamir | Leonard <strong>A</strong>dleman</p><p>RSA在各个领域都被有所应用，像数字签名，数字证书，SSH、HTTPS的加密连接，全部都是RSA的典型应用。在实际使用中，由于公钥加密的计算量大，速度慢，通常他会和加密对称算法一起使用：</p><p>公钥加密算法常被用作最初连接的建立，而真正数据传输的过程会交给对称加密算法来处理</p><p>以上便是公钥加密算法RSA的全部奥秘，总结一下：</p><p>双方都生成私钥和公钥，<br>双方只首次建立链接时互相交换公钥，<br>然后双方互相用对面的公钥进行数据加密，<br>双方互相发送加密后的密文，<br>然后双方自己用自己本地的私钥进行解密</p><p>也就是说整个过程中：网络中交换数据时用对面给的公钥加密；本地自己收到加密后的密文后自己用私钥解密</p><p>因为整个过程只有公钥加密后的密文，还有公钥在网络上传递，而该密文因为即时你知道公钥，也由于大数难以质数分解的原因无法反推，必须用私钥解密，所以是很安全的</p><p>用人话说就是：见面时，我给你一把打开的锁，但是不给你钥匙，你给我发送文件就用我的锁给锁上，然后我自己能用钥匙打开但是别人因为没钥匙打不开，而因为我一直拿着钥匙没给别人看过，所以也不可能有人偷了我的钥匙</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Hexo的Deploy功能</title>
      <link href="posts/c72897d5.html"/>
      <url>posts/c72897d5.html</url>
      
        <content type="html"><![CDATA[<p>最近我在部署我的Hexo博客时遇到了这个问题，就是每次生成博客文件时都要手动push就很麻烦，这篇教程就教大家如何正确打开hexo的deploy功能</p><h2 id="注册Github账号并配置SSH-KEY"><a href="#注册Github账号并配置SSH-KEY" class="headerlink" title="注册Github账号并配置SSH-KEY"></a>注册Github账号并配置SSH-KEY</h2><p>相信注册Github账号这个大家都会，就不说了，详细说一下这个配置ssh-key</p><ol><li>首先配置Git的登陆信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的github用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的github登录邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>生成 SSH 公私钥<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的github登录邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>设置 Github 的 ssh key<br>将 id_rsa.pub 的内容拷贝到 Github 的 ssh key 中<br><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/16/YxaU6wNIFlbMcfX.png" alt="image.png"></li><li>测试链接 Github 设置的 ssh key 免登陆是否生效<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ol><hr><p>上面的步骤配置好了后，下面的配置就很简单了</p><ol><li>新建git仓库<br>不说</li><li>配置 _config.yml<br>这个在你的hexo根目录的_config.yml中有写，这里放张截图<br><img src= "/img/friend_404.gif" data-lazy-src="https://i.loli.net/2021/01/16/MnFpYBlk8XQocsb.png" alt="image.png"><br><strong>branch不写的话它默认新建一条gh-pages分支，请注意</strong></li><li>安装hexo deploy插件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>安装好后就可以直接deploy到github了</li><li>Deploy到Github<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嗨! 是我啊!</title>
      <link href="posts/f5ab1c33.html"/>
      <url>posts/f5ab1c33.html</url>
      
        <content type="html"><![CDATA[<h2 id="对你没看错CQ又把他的blog大改了一顿"><a href="#对你没看错CQ又把他的blog大改了一顿" class="headerlink" title="对你没看错CQ又把他的blog大改了一顿"></a>对你没看错CQ又把他的blog大改了一顿</h2><p>这次真的超级<strong>香</strong>!<br>因为我终于搞懂butterfly这个主题咋用了!<br>Hexo香!!<br>(<del>太激动了</del>)<br>这回应该是 真 · 可能不改了<br>(<del>不是</del>)<br>完活(<del>耶，又水了一篇</del>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 又双叒叕 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
