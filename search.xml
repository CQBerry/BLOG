<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一个Terraria的奇妙好东西</title>
      <link href="2021/01/19/%E8%AE%B0%E4%B8%80%E4%B8%AATerraria%E7%9A%84%E5%A5%87%E5%A6%99%E5%A5%BD%E4%B8%9C%E8%A5%BF/"/>
      <url>2021/01/19/%E8%AE%B0%E4%B8%80%E4%B8%AATerraria%E7%9A%84%E5%A5%87%E5%A6%99%E5%A5%BD%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>HI!</p><p>这里是CHINQ啊，Terraria有个奇妙的东西</p><p>就是在旅途模式下的官方作弊的东西（鬼知道Terraria官方为什么要开发这个），反正特别强就是了</p><p>可是旅途模式只能在旅途地图使用，那么有没有什么办法把在旅途模式的作弊插件放到普通地图（除旅途外的所有类型地图）使用呢？</p><p>官方肯定是不允许你这样做的，但是，有一种东西，它叫：</p><p><strong>人物存档修改器</strong>…</p><hr><p>在旅途模式里，有很多作弊用的东西，就拿这个<code>God Mode</code>举例子，这玩意就相当于锁血，锁蓝（就是不掉血，不消耗魔法啦），那么这个东西要怎么带到别的地图使用呢？接着往下看吧！</p><p><a href="https://yal.cc/r/terrasavr/"><strong>Terrasavr</strong></a>————YellowAfterLife大佬开发的一个人物存档修改器，有网页端和客户端（<strong>不是广告</strong>）</p><blockquote><p>注: 因为是外国服务器，可能需要梯子，梯子请自备</p></blockquote><p>网站上有部分汉化的简体中文，字体也使用了Terraria的风格（只有英文才是），主界面是这样的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/RyCJeAWa82HSYIw.png" alt="image.png"></p><p>选择加载存档：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/d73BAFfYT9XK52z.png" alt="image.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/v28W5cr3gpV1Bwi.png" alt="image.png"></p><blockquote><p>不要在意我这个人物存档，乱改的，这里我只说说怎么把旅途模式的<code>God Mode</code>（其他同理）允许在其他存档使用</p></blockquote><hr><p>首先先在Terraria创建一个旅途人物，随便进入一个地图，把<code>God Mode</code>打开，保存并退出，接着你就可以找到你的人物存档是一个叫做：</p><p><code>name.plr</code>的文件（不知道存档在哪里的见上面的图）</p><p>我们将这个文件载入到Terrasavr中，并将其模式修改为除旅途模式的任意一个其他模式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/19/Bjn2mzG6Mrp8hEs.png" alt="image.png"></p><p>然后保存存档，将该存档覆盖你的老存档，现在即可进入其他世界体验旅途的快乐（不是）了！</p><p>因为旅途模式的<code>God Mode</code>并不依赖旅途使用，所以只修改模式并不会影响它的使用</p><p>总结：<br>创建旅途存档，把想要的作弊模式打开，<br>导入存档至Terrasavr，把模式修改为旅途之外，<br>保存存档，覆盖之前的老存档，<br>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> 水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terraria </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是RSA?</title>
      <link href="2021/01/18/%E4%BB%80%E4%B9%88%E6%98%AFRSA/"/>
      <url>2021/01/18/%E4%BB%80%E4%B9%88%E6%98%AFRSA/</url>
      
        <content type="html"><![CDATA[<div class="note success flat"><p>强烈建议放大观看，Mathjax渲染的公式有点小，见谅！</p></div><p>一直到上个世纪70年代，人们都还在使用对称加密算法，也就是说信息的收发方会通过事先商定好的密钥对数据进行加密和解密 </p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/17/QlDfwCdoiGFamLr.png" alt="image.png"></p><p>然而，这种加密方式有诸多缺陷，随着网络规模的不断增大，每多一个用户就需要保存额外的密钥，密钥的管理也将逐渐成为所有人的负担 </p><p>更加致命的是，密钥必须通过见面协商，而没有办法通过网络进行交换，因为密钥的传输过程需要进行加密，而没有密钥，则不能进行加密 </p><p>那有没有一种可能性，我们用不同的密钥对数据进行加密和解密</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/17/AzEm1Xr4OT5ayLe.png" alt="image.png"></p><p>对数据加密的密钥，即公钥，是公开的，而对数据解密的密钥却仅为接收者持有？</p><p><strong>这个问题，在1978年得到了解答</strong></p><hr><p>因为公钥是对所有人公开的信息，我们需要保证数据被公钥加密后，不能轻易地反推出来，那么什么算法单项计算容易，反推却极难呢？</p><p><strong>模运算</strong>(Modular Artithmetic)，又称求余计算，像计算机中的假随机生成的随机数，散列算法都是他的典型应用 </p><p>我来举个例子：</p><p>$$3^3\ mod\ 7$$</p><p>很简单，答案是6</p><p>$$3^3\ mod\ 7\ =\ 6$$</p><p>但已知答案是<code>6</code>，要求<code>x</code>，就很难了</p><p>$$3^x\ mod\ 7\ =\ 6$$</p><p>因为模运算不可逆的原因，我们只能带进一个数值一个一个去试，那如果这里出现了超级大的数，想逆推这个等式几乎不可能</p><p>$$3^x\ mod\ 9871649871751784351784561874657819346\ =\ 6$$</p><p>而公钥加密正是利用了模运算的这个特性，假设我们将原始数据表示成一个数<code>m</code>(message)，我们对它求<code>e</code>次幂</p><p>$$m^e$$</p><p><strong>e(encrypt)可以看成我们加密使用的密钥</strong></p><p>然后我们将结果除以N并取余数，最后得到密文<code>c</code>(cipher)</p><p>加密:</p><p>$$m^e\ mod\ N\ =\ c$$</p><p>解密:</p><p>$$c^d\ mod\ N\ =\ m$$</p><p><strong>d(decrypt)可以看成我们解密使用的密钥</strong></p><p>综合一下这两个式子，合并成下面这样:</p><p>$$m^{ed}\ mod\ N\ =\ m$$</p><p>可以发现，如何选取这里的<code>e, d</code>变成了公钥加密中最关键的问题…</p><hr><p>1763年，欧拉有了一个重要发现 ———— 欧拉定理(Euler’s Theorem)</p><p>$$m^{\phi(n)}\ =\ 1\ (mod\ n)$$</p><p>对于一个任何与<code>n</code>互质的正整数<code>m</code>，提取他的<code>φ(n)</code>次方，并处以<code>n</code>去余数，结果永远等于<code>1</code></p><p>那么，<code>φ(n)</code>又是什么呢？</p><p>它代表在小于或等于<code>n</code>的正整数中，有多少个与<code>n</code><strong>互质</strong>的数</p><p>我举个例子，这里我们取<code>n = 6</code></p><p>我们会发现在小于等于<code>6</code>的正整数中，只有<code>1</code>和<code>5</code>与<code>6</code>互质，所以<code>φ(6) = 2</code></p><p>了解了<code>φ</code>后，我们回到欧拉定理，尝试着对公式进行一些简单的变换</p><p>$$m^{\phi(n)}\ =\ 1\ (mod\ n)$$</p><p>在等式的两端取<code>k</code>次幂</p><p>$$m^{k\phi(n)}\ =\ 1\ (mod\ n)$$</p><p><strong><code>k</code>在这里代表任意的正整数</strong></p><p>接着我们在两端同时乘<code>m</code></p><p>$$m^{k\phi(n)+1}\ =\ m\ (mod\ n)$$</p><p>最后我们将模运算写在等式的左边</p><p>$$m^{k\phi(n)+1}\ mod\ n\ =\ m$$</p><p>将这个公式和上面的加密解密公式对应起来，我们会发现这里公式的指数部分相同，则我们可以将<code>d</code>与<code>e</code>的关系表示成这种形式:</p><p>$$d\ =\ \frac{k\phi(n)+1}{e}$$</p><p>我们可以通过选取这里的<code>k, n, e</code>来计算出解密的密钥<code>d</code></p><p>而这个公式中的<code>φ(n)</code>，不是那么的简单，但它还恰巧是公钥加密中最关键的部分</p><p>实际上，要计算出<code>φ(n)</code>的唯一办法就是对这个<code>n</code>做质因数分解，然而大数的质因数分解本身是非常困难的事情，所以说当<code>n</code>特别大时，对<code>φ(n)</code>的求解可以看作是计算上不可行的</p><p>但是，如果<code>n</code>本身就是一个质数，那么情况就会有所改变</p><p>比如质数<code>7</code>，小于等于<code>7</code>的并于<code>7</code>互质的数有<code>1-6</code>，所以<code>φ(7)=6</code></p><p>所以，只要<code>n</code>是质数，则<code>φ(n) = n - 1</code></p><p>φ函数还有一个重要的特性，就是:</p><p>$$\phi(p\ \times\ q)\ =\ \phi(p)\ \times\ \phi(q)$$</p><p>例如，我们可以选取两个质数，<code>17</code>和<code>23</code>，则:</p><p>$$\phi(17\ \times\ 23)\ =\ \phi(17)\ \times\ \phi(23)\ =\ 16\ \times\ 22\ =\ 352$$</p><p>因此我们可以轻易求得$\phi(17 \times 23) = \phi(391) = 352$</p><p>带入我们之前的公式:$d\ =\ \frac{k\phi(n)+1}{e}$</p><p>然后选取一个较小的数<code>e = 3</code>，这里我们需要保证它与<code>φ(n)</code>互质</p><p>于是在<code>k = 5</code>的情况下：</p><p>$$d\ =\ \frac{k\phi(n)+1}{e}\ =\ \frac{5\ \times\ 352\ +\ 1}{3}\ =\ 587$$</p><p>求出了私钥<code>d</code>，我们不需要<code>p</code>和<code>q</code>了，算法会将<code>e</code>和<code>n</code>公布，做加密的公钥<code>(public key)</code>，而<code>d</code>做保存下来作为解密时用的私钥<code>(private key)</code></p><p>其他人因为不知道<code>p, q</code>这两个关键的质因数，也没有办法计算出<code>φ(n)</code>，也没法破解这里的私钥<code>d</code></p><p>公钥加密正是利用了这个信息不对等，让加密者能够快速构造出一个<code>φ(n)</code>，而其他人却无法在有限的时间内求解它</p><p>我们可以用求得的<code>e, d, n</code>来模拟一段信息加密解密过程：</p><p>$$e\ =\ 3\ |\ d\ =\ 587\ |\ n\ =\ 391$$</p><p>我们要加密的字符是<code>a</code>，<code>a</code>的ascii编码是<code>97</code>，所以<code>m = 97</code></p><p>于是$97^3\ mod\ 391\ =\ 79$，<code>79</code>是我们加密后的密文，即<code>c</code></p><p>为了解密，我们计算$79^{587}\ mod\ 391\ =\ 97$，计算出原始数据为<code>97</code></p><p>以上讲到的，便是公钥加密算法的全部工作原理，这个算法在首次被发现后就被政府作为机密尘封起来，后来又在1977年又被三个麻省理工的数学家独立发掘，即为当下众所周知的著名的RSA算法，RSA这个名字也是由三位数学家的姓来命名的：</p><p>Ron <strong>R</strong>ivest | Adi <strong>S</strong>hamir | Leonard <strong>A</strong>dleman</p><p>RSA在各个领域都被有所应用，像数字签名，数字证书，SSH、HTTPS的加密连接，全部都是RSA的典型应用。在实际使用中，由于公钥加密的计算量大，速度慢，通常他会和加密对称算法一起使用：</p><p>公钥加密算法常被用作最初连接的建立，而真正数据传输的过程会交给对称加密算法来处理</p><p>以上便是公钥加密算法RSA的全部奥秘，总结一下：</p><p>双方都生成私钥和公钥，<br>双方只首次建立链接时互相交换公钥，<br>然后双方互相用对面的公钥进行数据加密，<br>双方互相发送加密后的密文，<br>然后双方自己用自己本地的私钥进行解密</p><p>也就是说整个过程中：网络中交换数据时用对面给的公钥加密；本地自己收到加密后的密文后自己用私钥解密</p><p>因为整个过程只有公钥加密后的密文，还有公钥在网络上传递，而该密文因为即时你知道公钥，也由于大数难以质数分解的原因无法反推，必须用私钥解密，所以是很安全的</p><p>用人话说就是：见面时，我给你一把打开的锁，但是不给你钥匙，你给我发送文件就用我的锁给锁上，然后我自己能用钥匙打开但是别人因为没钥匙打不开，而因为我一直拿着钥匙没给别人看过，所以也不可能有人偷了我的钥匙</p>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Hexo的Deploy功能</title>
      <link href="2021/01/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84Deploy%E5%8A%9F%E8%83%BD/"/>
      <url>2021/01/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84Deploy%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>最近我在部署我的Hexo博客时遇到了这个问题，就是每次生成博客文件时都要手动push就很麻烦，这篇教程就教大家如何正确打开hexo的deploy功能</p><h2 id="注册Github账号并配置SSH-KEY"><a href="#注册Github账号并配置SSH-KEY" class="headerlink" title="注册Github账号并配置SSH-KEY"></a>注册Github账号并配置SSH-KEY</h2><p>相信注册Github账号这个大家都会，就不说了，详细说一下这个配置ssh-key</p><ol><li>首先配置Git的登陆信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的github用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的github登录邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>生成 SSH 公私钥<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的github登录邮箱&quot;</span><br></pre></td></tr></table></figure></li><li>设置 Github 的 ssh key<br>将 id_rsa.pub 的内容拷贝到 Github 的 ssh key 中<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/16/YxaU6wNIFlbMcfX.png" alt="image.png"></li><li>测试链接 Github 设置的 ssh key 免登陆是否生效<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ol><hr><p>上面的步骤配置好了后，下面的配置就很简单了</p><ol><li>新建git仓库<br>不说</li><li>配置 _config.yml<br>这个在你的hexo根目录的_config.yml中有写，这里放张截图<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/16/MnFpYBlk8XQocsb.png" alt="image.png"><br><strong>branch不写的话它默认新建一条gh-pages分支，请注意</strong></li><li>安装hexo deploy插件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>安装好后就可以直接deploy到github了</li><li>Deploy到Github<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 干货 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嗨! 是我啊!</title>
      <link href="2021/01/16/%E5%97%A8!%20%E6%98%AF%E6%88%91%E5%95%8A!/"/>
      <url>2021/01/16/%E5%97%A8!%20%E6%98%AF%E6%88%91%E5%95%8A!/</url>
      
        <content type="html"><![CDATA[<h2 id="对你没看错CQ又把他的blog大改了一顿"><a href="#对你没看错CQ又把他的blog大改了一顿" class="headerlink" title="对你没看错CQ又把他的blog大改了一顿"></a>对你没看错CQ又把他的blog大改了一顿</h2><p>这次真的超级<strong>香</strong>!<br>因为我终于搞懂butterfly这个主题咋用了!<br>Hexo香!!<br>(<del>太激动了</del>)<br>这回应该是 真 · 可能不改了<br>(<del>不是</del>)<br>完活(<del>耶，又水了一篇</del>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 又双叒叕 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
